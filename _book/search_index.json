[["index.html", "Visualización y geolocalización de datos Prólogo ¿Por qué leer este libro? Objetivos de aprendizaje Estructura del libro Datos", " Visualización y geolocalización de datos Diego Hernangómez Gema Fernández-Avilés 2022-02-03 Prólogo Este libro presenta los conceptos teóricos y prácticos necesarios para llevar a cabo correctamente la de y su Poner un poco de rollo ¿Por qué leer este libro? Los están presentes en la mayoría de los fenómenos que nos rodean, es un hecho que no podemos obviar y que aporta información muy valiosa en la mayoría de los análisis estadísticos llevados a cabo en distintas disciplinas tales como la Sociología, la Inteligencia Artificial, la Economía, la Antropología, la Biología, etc La representación gráfica de los mismos adquiere un papel crucial, ya que (i) se detectan relaciones y patrones entre las variables más fácilmente, (ii) hacen que la distribución del fenómeno se comprenda y recuerde rapidamente, (iii) grandes medidas de datos estadísticos se puede visualizar de un vistazo, (iv) permiten sacar a la luz hechos y relaciones ocultos que estimulen el pensamiento analítico y la investigación. La principal contribución del libro es mostrar el proceso de vsiualización de datos georreferenciados de principio a fin. ******* rematar Objetivos de aprendizaje Poner algo Estructura del libro El Capítulo ?? introduces a new topic, and  Datos DIEGO, YO NO SE SI DEBEMOS DEJAR TODOS, SEGÚN VEAMOS, GEMA: NO SE QUE QUIERES HACER AQUI, LA VERDAD, temperatura mínima en el aire en España renta delitos valencia porcentaje de mujeres en clm tráfico madrid Hospitales en toledo Rio tajo ?? Elevación en España Puertos contar un poco al final PARA decir que tenemos una amplia variedad de aplicaciones para ilustrar los conceptos bla bla ojo, ver cómo entra esto en el libro o no Libros de referencia: Spatial Data Science with applications in R Geocomputation with R Displaying time series, spatial and space-time data with R Recursos de estadística espacial en R: rspatial R-spatial "],["la-revolución-de-los-geodatos.html", "Capítulo 1 La revolución de los geodatos", " Capítulo 1 La revolución de los geodatos Que estamos en la la era del dato, que los datos son el petróleo del siglo XXI y que estamos rodeados de datos es una cuestión que ya hemos hecho inherente a nosotros. Vivimos en el momento del dato, donde la profesión de Data Scientist se ha convertido en la profesión más sexy del siglo XXI según vaticinó en 2012 Harvard Business Review. Cada segundo se producen 1,7 MB de datos/persona y cada año esta cifra se duplica se duplica. Este incremento exponencial de los datos ha sido posible, sin duda, gracias al desarrollo de la tecnología, la informática, los ordenadores, los teléfonos móviles, los satélites, internet, etc y asociado a estas nuevas herramientas, se ha producido una lluvia sin precedentes hasta el momento de datos espaciales o datos georreferenciados. Cada teléfono inteligente tiene un Receptor de posicionamiento Global (en inglés, Global Positioning System, GPS) y, además, convivimos con una multitud de sensores en dispositivos que van desde satélites y vehículos semi-autónomos hasta científicos ciudadanos que miden incesantemente cada parte del mundo. La tasa de datos producidos es abrumadora. Un vehículo autónomo, por ejemplo, puede generar 100 GB de datos por día (The Economist, 2016). Esta revolución de los geodatos y el análisis de los datos espaciales junto con los Sistemas de Información Geográficos (habitualmente expresados como GIS por las siglas de su nombre en inglés Geographical Information System) no sólo han impulsado la demanda de hardware informático de alto rendimiento y software escalable y eficiente para manejar y extraer la información, lo que se conoce como Geocomputación, sino que han dado lugar una nueva rama de conocimiento, Ciencia de Datos Espaciales comúnmente conocida como Spatial Data Scicene (SDS). Como ejemplo de este abrumador desarrollo de datos georreferenciados, el Ministerio de Transportes, Movilidad y Agenda Urbana llevó a cabo durante los años 2020 y 2021 el denominado Estudio de movilidad con Big Data, cuya fuente principal de datos fue el posicionamiento de los teléfonos móviles anonimizado. Estos datos permiten, por ejemplo, analizar la movilidad entre diversas zonas del territorio español de manera diaria (véase la Fig. 1.1). Este tipo de análisis era impensable hace tan solo unos años. Figura 1.1: Análisis de movilidad COVID "],["datos-geográficos.html", "Capítulo 2 Datos geográficos 2.1 Contexto general 2.2 Conceptos clave", " Capítulo 2 Datos geográficos 2.1 Contexto general La palabra geográfico puede dividirse en geo (tierra) + gráfico (dibujo/mapa). Por tanto, los datos geográficos contienen información de cualquier variable referenciada en un punto/área de la superficie terrestre y pueden representarse en mapas. El desarrollo de los datos geográficos ha producido grandes bases de datos espaciales y, a su vez, ha propiciado el desarrollo de herramientas para su tratamiento como los ya mencionados Sistemas de información geográficos y la Geocomputación. ¿Qué hace un Sistemas de información geográfico? Un Sistema de información geográfica (SIG) es una herramienta que crea, administra, analiza y mapea todo tipo de datos. GIS conecta datos a un mapa, integrando datos de ubicación (dónde están las cosas) con todo tipo de información descriptiva (cómo son las cosas allí). Esto proporciona una base para el mapeo y el análisis que se utiliza en la ciencia y en casi todas las industrias. GIS ayuda a los usuarios a comprender patrones, relaciones y contexto geográfico. Los beneficios incluyen una mejor comunicación y eficiencia, así como una mejor gestión y toma de decisiones. La Fig. 2.1 muestra el flujo de trabajo de los SIG, que va desde (i) la elaboración de mapas, (ii) la obtención de geodatos o datos espaciales, (iii) el análisis de los datos geográficamente referenciados y (iv) la edición, mapeo y presentación de los resultados. Figura 2.1: Flujo de trabajo de los GIS. Fuente: https://www.esri.com/en-us/what-is-gis/overview Pero es más, el desarrollo de la Inteligencia Artificial y la Inteligencia computacional se han convertido en herramientas creativas y complementarias a los convencionales GIS, dando origen a la Geocomputación, que trata de utilizar el poder de los ordenadores para hacer cosas con los datos geográficos. ¿Y que es la Geocomputación? En primer lugar, señalar que, aunque la geocomputación es un término relativamente nuevo se encuentra influenciado por otros términos clásicos. De manera sencilla puede definirse como el proceso de aplicar tecnologías de computación a problemas geográficos (Rees and Turton 1998). Abrahart et al. (2000) aporta más elementos formales a esta definición destacando que la geocomputación trata sobre los diferentes tipos de geodatos, y sobre el desarrollo de geo-herramientas relevantes en un contexto científico. La geocomputación está muy relacionada con otros términos como los SIG, ya definidos, y con diversos tipos de campos científicos, como las Geociencias, las Ciencias atmosféricas y climáticas, la Geoinformática, la Topología, la Ecología y las Ciencia de datos geográficos (GDS, Geographic Data Science). Cada término comparte un énfasis en un enfoque científico (que implica reproducible y falsable) influenciado por los GIS, aunque sus orígenes y principales campos de aplicación difieren. La geocomputación es ámpliamente utilizada en ámbitos como la sociología, el análisis político o el desarrollo de aplicaciones para móviles. Por tanto, usamos geocomputación como un sinónimo aproximado que encapsula a todas las ciencias que buscan usar datos geográficos para trabajos científicos aplicados. ¿Por que R para datos geográficos? R es una herramienta con capacidades avanzadas de análisis, modelado y visualización. Por ejemplo, los nuevos entornos de desarrollo integrado (en inglés, Integrated Development Environment, IDE), como RStudio, han hecho que R sea más fácil de usar para muchos, facilitando la creación de mapas con un panel dedicado a la visualización interactiva (Lovelace, Nowosad, and Münchow 2019). Además, el uso del código R permite la enseñanza de la geocomputación con referencia a ejemplos reproducibles en lugar de conceptos abstractos. Por ejemplo, de una forma relativamente sencialla, se puede geoposicionar de manera interactiva la localización de la Puerta del Sol en Madrid y, además, dejar la el código R para hacerlo reproducible, ver Fig. 2.2. library(leaflet) leaflet(width = &quot;100%&quot;, height = &quot;500px&quot;) %&gt;% addTiles() %&gt;% setView(-3.703548, 40.417147, zoom = 60) Figura 2.2: Localización interactiva de la Puerta del Sol en Madrid Por otra parte R dispone de cientos de librerías especializadas para datos espaciales. Una descripción detallada puede ver se en CRAN Task View: Analysis of Spatial Data Para no abrumar al lector, a continuación se muestran, de manera esquemática, las librerías más usadas para el tratamiento de datos espaciales y que se emplearán a lo largo de la asignatura Estadística Espacial y Espacio-Temporal, no sólo en el tema que nos ocupa: sp (Pebesma and Bivand 2021) y sf (Pebesma and Bivand 2021): para el tratamiento de clases y métodos de los datos vectoriales. raster (Hijmans 2022a),terra (Hijmans 2022b)y stars (Pebesma 2021b)para datos raster. gstat (Pebesma 2004) y geoR (Ribeiro Jr et al. 2020): para el análisis de datos geoestadísticos, ajuste y estimación de semivariogramas, interpolación, etc. spdep (Bivand and Wong 2018) para el análisis de datos con modelos de econometría espacial, creación de matrices de contiguidad/distancia W, estimación de modelos econométricos espaciales, etc spatstat (Baddeley and Turner 2005)para el análisis de procesos de puntos espaciales, intensidad, etc. 2.2 Conceptos clave Una vez visto el contexto actual de los datos georreferenciados y antes de entrar en detalle en su análisis, debemos tener en cuenta una serie de conceptos clave que se irán desarrollando a lo largo del tema. Hemos dicho que Geográfico = Geo (tierra) + gráfico (mapa). Por tanto, si tenemos varios datos geográficos, localizados en distintos puntos de la tierra, es porque tenemos las coordenadas que los posicionan en esos puntos concretos. Asociado a estas coordenadas debemos conocer el Sistema de referencia de espacial o Coordinate reference system (CRS) en el que están proyectadas dichas coordenadas. Por otra parte, los formatos de estos datos pueden ser vectores o raster como se explicará en la Sección 3. Si damos un paso más e incorporamos el concepto de distancia, pues es lógico pensar que en un fenómeno de interés, por ejemplo, la modelización de la cantidad y dirección de lava en La Palma tras la erupción del volcán Cumbre Vieja, la distancia es un factor clave, pues aquellas zonas más cercanas al volcán tendrán niveles más parecidos entre sí y con valores más altos que aquellas que están más alejadas En este caso el nivel de contaminación en el aire en La Palma no puede ser modelado como si las observaciones fuesen independientes pues las más cercanas entre sí serán más parecidas que las más lejanas, dando lugar al concepto de dependencia espacial. Y depende del tipo de datos espaciales tendremos tres grandes formas de abordar el tratamiento de los datos espaciales: geoestadística, procesos de punto y econometría espacial (véase Sección 3.3). Figura 2.3: Información espacial de la concentración de lava en Cumbre Vieja References "],["formatos.html", "Capítulo 3 Formatos de datos espaciales 3.1 Ficheros de datos espaciales 3.2 Modelo de datos 3.3 Sistema de Referencia de Coordenadas (CRS)", " Capítulo 3 Formatos de datos espaciales 3.1 Ficheros de datos espaciales Los datos espaciales, también conocidos como datos geoespaciales, son aquellos datos relacionados o que contienen información de una localización o área geográfica de la superficie de la Tierra. En los últimos años se han desarrollado diversos estándares de ficheros que permiten almacenar y compatir este tipo de datos. En esta sección presentamos de una manera breve algunos de los tipos de archivos más habituales empleados en el almacenamiento de geodatos. Información de vectores Las características de los datos de vector se analizan en profundidad en la Sección 3.2.1. Las extensiones más habituales de los archivos que contienen datos de vectores son: Ficheros con datos vector Tipo Extensión Shapefile .shp, .shx, .dbf GeoPackage vector .gpkg GeoJson .geojson GPX .gpx Geography Markup Language .gml Keyhole Markup Language .kml Adicionalmente, es también común encontrarse con datos espaciales distribuidos en ficheros planos (.csv, .txt o incluso Excel). Generalmente este tipo de datos corresponde a localizaciones (puntos) y la información geográfica suele especificarse en dos columnas que contienen las coordenadas de la localización. Tabla 3.1: Ejemplo: Coordenadas de Aeropuertos en España Ciudad longitud latitud Huesca -0.323300 42.08080 Palma De Mallorca 2.702896 39.59862 Lillo / Toledo -3.320560 39.71694 Valladolid -4.850000 41.70111 Sabadell 2.105030 41.52090 Madrid -3.785140 40.37067 Una nota importante sobre el uso de Shapefile Shapefile surgió como uno de los primeros formatos de intercambio de datos geográficos a principios de los años 90 del siglo XX, y en la actualidad es quizá el formato más empleado. Sin embargo tiene una serie de limitaciones que es necesario conocer: Es un formato multiarchivo: El formato shapefile se compone de diversos archivos que son necesarios para la correcta lectura de los datos. Es por ello que cuando se intercambia información han de proporcionarse como mínimo los archivos con extensiones .shp, .shx, .dbf (por ejemplo: datos.shp, datos.shx, datos.dbf ). Lo mas habitual es distribuirlos en un fichero .zip del que se deben extraer todos estos archivos. El Sistema Geográfico de Coordenadas es opcional: Como explicaremos en la Sección 3.3, esta información es crucial para trabajar con datos geográficos, sin embargo el estándar Shapefile lo considera opcional, siendo esta una limitación importante. Además de estas limitaciones, existen otras relacionadas con el nombre y la longitud de los campos, o la capacidad de almacenamiento de los Shapefiles, que se pueden consultar en varios recursos web que profundizan en este tema (Morales (2012), Cepicky and OpenGeoLabs (2017)). Un buen reemplazo de este formato es el formato GeoPackage (.gpkg ), que no tiene este tipo de limitaciones. Información de ráster Las características de los datos ráster se analizan en profundidad en la Sección 3.2.2. Las extensiones más habituales de los archivos que contienen datos ráster son: Ficheros con datos ráster Tipo Extensión ASCII Grid .asc GeoTIFF .tif, .tiff Enhanced Compression Wavelet .ecw 3.2 Modelo de datos En el ámbito del análisis espacial en R, se pueden clasificar el formato de datos espaciales en función del modelo de datos (Lovelace, Nowosad, and Münchow 2019). Se pueden distinguir dos tipos de modelos de datos: vectores y ráster. 3.2.1 Datos de vectores Este modelo está basado en puntos georeferenciados. Los puntos pueden representar localizaciones específicas, como la localización de edificios: library(ggplot2) library(sf) # Hospitales en Toledo segun Eurostat hosp_toledo &lt;- st_read(&quot;data/hosp_toledo.geojson&quot;, quiet = TRUE) # Plot ggplot() + geom_sf( data = hosp_toledo, aes(fill = &quot;Centros Sanitarios&quot;), color = &quot;blue&quot; ) + labs( caption = &quot;Datos: Eurostat&quot;, title = &quot;Hospitales y Centros de Salud en Toledo&quot;, fill = &quot;&quot; ) + theme_minimal() + theme(legend.position = &quot;bottom&quot;) Figura 3.1: Datos vector: Puntos Estos puntos también pueden estar conectados entre sí, de manera que formen geometrías más complejas, como líneas y polígonos: tajo &lt;- st_read(&quot;data/tajo_toledo.shp&quot;, quiet = TRUE) toledo &lt;- st_read(&quot;data/toledo_ciudad.gpkg&quot;, quiet = TRUE) ggplot(toledo) + geom_sf(fill = &quot;cornsilk2&quot;) + geom_sf(data = tajo, col = &quot;lightblue2&quot;, lwd = 2, alpha = 0.7) + geom_sf(data = hosp_toledo, col = &quot;blue&quot;) + coord_sf( xlim = c(-4.2, -3.8), ylim = c(39.8, 39.95) ) + theme_minimal() Figura 3.2: Datos vector: Puntos, líneas y polígonos En la Fig. 3.2, el río Tajo está representado como una línea (sucesión de puntos unidos entre sí) y la ciudad de Toledo como un polígono (línea de puntos cerrada formando un continuo). A modo ilustrativo, la Fig. 3.3 representa la descomposición en puntos de todos los datos espaciales representados en la Fig. 3.2. Figura 3.3: Datos vector: Descomposición en puntos 3.2.2 Datos ráster Los datos ráster son datos representandos en una rejilla rectangular de píxeles (denomindada matriz) que se puede visualizar en diversos dispositivo de representación. El caso más cotidiano de un ráster es una fotografía, donde la imagen se representa como una serie de celdas, determinadas por la resolución de la imagen (número total de píxeles, determinados como número de píxeles en cada fila por número de píxeles en cada columna) y el color que presenta cada uno de estos píxeles. En el ámbito de los datos espaciales, la definición es muy similar. Un archivo ráster está formado por una malla regular de píxeles georreferenciada, tal y como muestra la Fig. 3.4: library(raster) elev &lt;- raster(&quot;data/Toledo_DEM.tiff&quot;) plot(elev, main = &quot;Elevación de la provincia de Toledo&quot;) # Mostramos el grid pols &lt;- rasterToPolygons(elev) plot(pols, add = TRUE, border = &quot;grey90&quot;) # Añadimos la provincia Tol_prov &lt;- st_read(&quot;data/Toledo_prov.gpkg&quot;, quiet = TRUE) # Si queremos solamente la forma en sf, usamos st_geometry plot(st_geometry(Tol_prov), add = TRUE) Figura 3.4: Datos ráster En la Fig. 3.4, el objeto ráster elev tiene únicamente una capa (denominada ESP_alt). Eso implica que cada píxel tiene asociado un único valor, en este caso, en este caso la altitud media del terreno observada: Tabla 3.2: Datos de un ráster (detalle) x y Toledo_DEM -5.391667 40.3 1498.312 -5.358333 40.3 1701.125 -5.325000 40.3 1825.312 -5.291667 40.3 1739.062 -5.258333 40.3 1756.062 -5.225000 40.3 1659.688 -5.191667 40.3 1607.375 -5.158333 40.3 1809.562 -5.125000 40.3 1874.625 -5.091667 40.3 1691.312 -5.058333 40.3 1511.500 -5.025000 40.3 1207.000 -4.991667 40.3 1160.125 -4.958333 40.3 1396.125 -4.925000 40.3 1624.125 Figura 3.5: Datos ráster: Detalle Los rásters pueden contener varias capas (o layers), de manera que cada píxel puede tener asociados varios valores. Volviendo al ejemplo de la fotografía, en un modelo simple de color RGB cada píxel lleva asociado 3 valores (rojo, verde o azul), de manera que al combinar las tres capas se puede definir un color distinto en cada píxel. En la Fig. 3.6 vamos a usar una imagen de mapa georreferenciada, como las proporcionadas por servicios de mapas online, para analizar su composición. Figura 3.6: Datos ráster con varias bandas El ráster se puede descomponer en las tres capas RGB mencionadas anteriormente: Tabla 3.3: Datos de un ráster multicapa (detalle) x y lyr.1 lyr.2 lyr.3 -5.466412 40.34418 215.2128 208.1061 190.5410 -5.463875 40.34418 228.0369 223.1854 211.2115 -5.461338 40.34418 229.3495 224.3414 213.4325 -5.458800 40.34418 215.8592 208.8660 191.2922 -5.456263 40.34418 219.2696 212.8231 196.6812 -5.453725 40.34418 235.0954 231.4222 222.4115 -5.451188 40.34418 240.3514 237.9094 231.4736 -5.448651 40.34418 237.2358 233.7561 226.2005 -5.446113 40.34418 229.9570 225.3262 214.6201 -5.443576 40.34418 226.7812 221.6796 209.2929 -5.441038 40.34418 222.3593 216.5022 202.0188 -5.438501 40.34418 220.9312 214.9060 200.0306 -5.435964 40.34418 224.7755 219.2661 206.2156 -5.433426 40.34418 222.0479 216.0124 201.6103 -5.430889 40.34418 225.0516 219.8074 207.0263 Figura 3.7: Datos ráster multicapa: Descomposición Figura 3.8: Datos ráster multicapa: Descomposición 3.3 Sistema de Referencia de Coordenadas (CRS) Un sistema de referencia de coordenadas (o CRS por sus siglas en inglés, Coordinate Reference System) permite relacionar datos espaciales con su localización en la superficie terrestre. Los CRS constituyen por tanto un aspecto fundamental en el análisis y representación de datos espaciales, ya que nos permiten identificar con exactitud la posición de los datos sobre el globo terráqueo. Así mismo, cuando se trabaja con datos espaciales provenientes de distintas fuentes de información, es necesario comprobar que dichos datos se encuentran definidos en el mismo CRS: Figura 3.9: Representación de mismos valores de coordenadas en distintos CRS En la Fig. 3.9, ambos puntos (verde y rojo) tienen los mismos valores de coordenadas en los ejes X e Y, en este caso las correspondientes a la ciudad de Toledo. Sin embargo, presentan distintos CRS. Por este motivo, al representar ambos puntos en un mapa, se observa que no se están refiriendo a la misma localización geográfica. Esto es así porque el CRS define la referencia (punto x=0 e y =0) y las unidades de los ejes (grados, metros, millas). Como conclusión, además de disponer de las coordenadas de los datos espaciales, es necesario conocer el CRS en el que están definidos para conocer de manera exacta su localización geográfica. Además, nótese que para cualquier análisis de datos espaciales es necesario que todos los geodatos se encuentren referenciados en el mismo CRS. Esto se consigue transformando (o proyectando) los datos a un CRS común, nunca sobreescribiendo el CRS de los mismos. 3.3.1 Tipos de CRS A continuación se definen los dos grandes tipos de CRS, los CRS geográficos y los CRS proyectados. 3.3.1.1 CRS geográficos Los CRS geográficos son aquellos en los que los parámetros empleados para localizar una posición espacial son la latitud y la longitud: Latitud: Es la distancia angular expresada en grados sobre el plano definido por el ecuador terrestre. Determina la posición sobre de una localización en el eje Norte-Sur de la Tierra y toma valores en el rango \\([-90º,90º]\\) . Las líneas imaginarias determinadas por una sucesión de puntos con la misma latitud a lo largo del eje Este-Oeste se denominan paralelos (Ver Fig. 3.10). Longitud: Es la distancia angular expresada en grados sobre el plano definido por el meridiano de Greenwich. Determina la posición sobre de una localización en el eje Este-Oeste de la Tierra y toma valores en el rango \\([-180º,180º]\\) . Las líneas imaginarias determinadas por una sucesión de puntos con la misma longitud a lo largo del eje Este-Oeste se denominan meridianos (Ver Fig. 3.10). Figura 3.10: Paralelos y Meridianos terrestres Es muy importante destacar que en un sistema de coordenadas geográfico, es decir, basado en latitudes y longitudes, las distancias entre dos puntos representan distancias angulares. Por ejemplo, la distancia entre el meridiano de Greenwich y el meridiano correspondiente a la longitud 20º siempre es de +20º. Sin embargo, debido a la forma esférica de la Tierra, la longitud en metros entre ambos meridianos no es constante. Figura 3.11: Distancia entre meridianos en distintas latitudes 3.3.1.2 CRS proyectados La representación de formas tridimensionales en un soporte plano (dos dimensiones) presenta algunos retos. Por ello, es habitual trabajar con proyecciones de mapas. Una proyección geográfica es un método para reducir la superficie de la esfera terrestre a un sistema cartesiano de dos dimensiones. Para ello, es necesario transformar las coordenadas longitud y latitud en coordenadas cartesianas x e y. Es importante destacar que las proyecciones pueden incluir un punto de origen (X=0, Y=0) y unas unidades de distancia (habitualmente metros) específicas. Por ejemplo, la proyección cónica equiáreas de Albers (específica para Estados Unidos) define su punto de referencia (0,0) en la latitud 40º N y longitud 96º, y la unidad de variación están definida en metros. De ahí la importancia de conocer el CRS de los datos geográficos, como se expuso al principio de este tema. El Anexo A proporciona más información sobre los tipos de CRS proyectados. 3.3.2 Trabajando con proyecciones en R Existe toda una serie de proyecciones predefinidas, identificadas mediante los códigos EPSG, ESRI, WKT o proj4 (en desuso en R, pero todavía admitidos). Existen varios recursos web donde se pueden consultar y seleccionar los códigos correspondientes: https://epsg.io/ https://spatialreference.org/ https://proj.org/operations/projections/index.html Algunos de los códigos de proyecciones que es fundamental conocer son: EPSG: 4326: Proyección correspondiente a WGS 84, que es el sistema usado por los sistemas GPS. Cuando trabajemos con coordenadas geográficas longitud/latitud, este es habitualmente el CRS de referencia. EPSG: 3857: Código correspondiente a la proyección de Mercator, usada habitualmente por servicios como Google Maps, etc. Se pueden consultar otros CRS de uso común en España en la página del Ministerio de Agricultura, Pesca y Alimentación En la sección 3.3.3 veremos cómo encontrar un CRS usando el paquete crsuggest (Walker 2021). El paquete sf (Pebesma 2021a)permite obtener los parámetros de cualquier proyección mediante la función st_crs(): (i) EPSG WGS 84 (Sistema Global GPS): EPSG 4326 library(sf) # Ejemplo: EPSG WGS 84 (Sistema Global GPS): EPSG 4326 st_crs(4326) #&gt; Coordinate Reference System: #&gt; User input: EPSG:4326 #&gt; wkt: #&gt; GEOGCRS[&quot;WGS 84&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; CS[ellipsoidal,2], #&gt; AXIS[&quot;geodetic latitude (Lat)&quot;,north, #&gt; ORDER[1], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; AXIS[&quot;geodetic longitude (Lon)&quot;,east, #&gt; ORDER[2], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; USAGE[ #&gt; SCOPE[&quot;Horizontal component of 3D system.&quot;], #&gt; AREA[&quot;World.&quot;], #&gt; BBOX[-90,-180,90,180]], #&gt; ID[&quot;EPSG&quot;,4326]] (ii) ESRI North America Albers Equal Area Conic: ESRI:102008 # Usando código ESRI North America Albers Equal Area Conic st_crs(&quot;ESRI:102008&quot;) #&gt; Coordinate Reference System: #&gt; User input: ESRI:102008 #&gt; wkt: #&gt; PROJCRS[&quot;North_America_Albers_Equal_Area_Conic&quot;, #&gt; BASEGEOGCRS[&quot;NAD83&quot;, #&gt; DATUM[&quot;North American Datum 1983&quot;, #&gt; ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433]]], #&gt; CONVERSION[&quot;North_America_Albers_Equal_Area_Conic&quot;, #&gt; METHOD[&quot;Albers Equal Area&quot;, #&gt; ID[&quot;EPSG&quot;,9822]], #&gt; PARAMETER[&quot;Latitude of false origin&quot;,40, #&gt; ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8821]], #&gt; PARAMETER[&quot;Longitude of false origin&quot;,-96, #&gt; ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8822]], #&gt; PARAMETER[&quot;Latitude of 1st standard parallel&quot;,20, #&gt; ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8823]], #&gt; PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,60, #&gt; ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8824]], #&gt; PARAMETER[&quot;Easting at false origin&quot;,0, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8826]], #&gt; PARAMETER[&quot;Northing at false origin&quot;,0, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8827]]], #&gt; CS[Cartesian,2], #&gt; AXIS[&quot;(E)&quot;,east, #&gt; ORDER[1], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; AXIS[&quot;(N)&quot;,north, #&gt; ORDER[2], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; USAGE[ #&gt; SCOPE[&quot;Not known.&quot;], #&gt; AREA[&quot;North America - onshore and offshore: Canada - Alberta; British Columbia; Manitoba; New Brunswick; Newfoundland and Labrador; Northwest Territories; Nova Scotia; Nunavut; Ontario; Prince Edward Island; Quebec; Saskatchewan; Yukon. United States (USA) - Alabama; Alaska (mainland); Arizona; Arkansas; California; Colorado; Connecticut; Delaware; Florida; Georgia; Idaho; Illinois; Indiana; Iowa; Kansas; Kentucky; Louisiana; Maine; Maryland; Massachusetts; Michigan; Minnesota; Mississippi; Missouri; Montana; Nebraska; Nevada; New Hampshire; New Jersey; New Mexico; New York; North Carolina; North Dakota; Ohio; Oklahoma; Oregon; Pennsylvania; Rhode Island; South Carolina; South Dakota; Tennessee; Texas; Utah; Vermont; Virginia; Washington; West Virginia; Wisconsin; Wyoming.&quot;], #&gt; BBOX[23.81,-172.54,86.46,-47.74]], #&gt; ID[&quot;ESRI&quot;,102008]] (iii) Usando proj4string: Robinson: +proj=robin # Usando proj4string: Robinson st_crs(&quot;+proj=robin&quot;) #&gt; Coordinate Reference System: #&gt; User input: +proj=robin #&gt; wkt: #&gt; PROJCRS[&quot;unknown&quot;, #&gt; BASEGEOGCRS[&quot;unknown&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; ID[&quot;EPSG&quot;,6326]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8901]]], #&gt; CONVERSION[&quot;unknown&quot;, #&gt; METHOD[&quot;Robinson&quot;], #&gt; PARAMETER[&quot;Longitude of natural origin&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8802]], #&gt; PARAMETER[&quot;False easting&quot;,0, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8806]], #&gt; PARAMETER[&quot;False northing&quot;,0, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8807]]], #&gt; CS[Cartesian,2], #&gt; AXIS[&quot;(E)&quot;,east, #&gt; ORDER[1], #&gt; LENGTHUNIT[&quot;metre&quot;,1, #&gt; ID[&quot;EPSG&quot;,9001]]], #&gt; AXIS[&quot;(N)&quot;,north, #&gt; ORDER[2], #&gt; LENGTHUNIT[&quot;metre&quot;,1, #&gt; ID[&quot;EPSG&quot;,9001]]]] La mayoría de los objetos espaciales serán de la clase sf, por tanto, resulta interesante conocer cómo se proyectan estos objetos. Es posible proyectar un objeto sf mediante la función st_transform(). En el siguiente ejemplo vemos cómo partimos de un objeto con EPSG:4326 y cambiamos su proyección a otras proyecciones, como Mercator o Robinson. En este ejemplo usaremos los datos espaciales de los países del mundo proporcionados de Eurostat, a los que accederemos usando el paquete giscoR (Hernangómez 2022a) : # Usa datos del paquete giscoR library(giscoR) paises &lt;- gisco_get_countries() # Comprobamos el CRS de estos datos # Se puede almacenar en un objeto y usar posteriormente # Vemos que es EPSG:4326, por tanto son coordenadas geográficas longitud/latitud st_crs(paises) #&gt; Coordinate Reference System: #&gt; User input: EPSG:4326 #&gt; wkt: #&gt; GEOGCS[&quot;WGS 84&quot;, #&gt; DATUM[&quot;WGS_1984&quot;, #&gt; SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]], #&gt; AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]], #&gt; UNIT[&quot;degree&quot;,0.0174532925199433, #&gt; AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]], #&gt; AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]] # Plot plot(st_geometry(paises), axes = TRUE) Figura 3.12: Proyección del mundo en coordenadas geográficas (EPSG 4326) # Proyectamos a Mercator # El eje cambia porque Mercator usa metros paises_merc &lt;- st_transform(paises, st_crs(3857)) plot(st_geometry(paises_merc), axes = TRUE) Figura 3.13: Proyección del mundo en Mercator (EPSG 3857) # Proyectamos a Robinson paises_robin &lt;- st_transform(paises, st_crs(&quot;+proj=robin&quot;)) plot(st_geometry(paises_robin), axes = TRUE) Figura 3.14: Proyección del mundo en Robinson (+proj=robin) Como se comentó anteriormente, cuando se usan geodatos de diversas fuentes, es necesario que todos presenten el mismo CRS. En la Fig 3.15 se muestra lo que ocurre si esto no se cumple: # Añadimos a este mapa puertos mundiales de giscoR puertos &lt;- gisco_get_ports() plot(st_geometry(paises_robin), main = &quot;Puertos en el mundo&quot;) plot(st_geometry(puertos), add = TRUE, col = &quot;red&quot;, pch = 20) Figura 3.15: Ejemplo: Puertos del mundo Vemos que ha habido algún tipo de error, ¿a que puede deberse? # Comprueba CRS st_crs(puertos) == st_crs(paises_robin) #&gt; [1] FALSE # Los puertos no están en Robinson! Proyectamos al mismo CRS puertos_robin &lt;- st_transform(puertos, st_crs(paises_robin)) plot(st_geometry(paises_robin), main = &quot;Puertos en el mundo&quot;) plot(st_geometry(puertos_robin), add = TRUE, col = &quot;blue&quot;, pch = 20) Figura 3.16: Ejemplo: Puertos del mundo, CRS alineados Como vemos, en el primer mapa (Fig. 3.15) los puertos se concentran en un único punto, dado que no están referenciados en el mismo CRS. Tras proyectarlos al mismo CRS, el mapa se representa adecuadamente (Fig. 3.16). En otros paquetes, como sp (Pebesma and Bivand 2021) o raster (Hijmans 2022a), existen funciones parecidas que nos van a permitir obtener los parámetros de un CRS y proyectar los objetos al CRS deseado. Cuando empleemos el paquete sp podemos usar las funciones CRS() y spTransform(): library(sp) # Convertimos sf a sp paises_sp &lt;- as(paises, &quot;Spatial&quot;) # En sp podemos usar: # CRS(&quot;+proj=robin&quot;) # # O también desde sf # CRS(st_crs(paises_robin)$proj4string) paises_sp_robin &lt;- spTransform(paises_sp, CRS(&quot;+proj=robin&quot;)) plot(paises_sp_robin) Figura 3.17: Transformaciones en sp En el caso de los objetos ráster del paquete raster, podemos usar crs() y projectRaster(): library(raster) # Extrae información de altitud para España elev &lt;- raster(&quot;data/ESP_msk_alt.grd&quot;) # Transforma elev_robinson &lt;- projectRaster(elev, crs = crs(&quot;+proj=robin&quot;)) plot(elev_robinson) Figura 3.18: Transformaciones en raster Por último, en el paquete terra (Hijmans 2022b) las funciones correspondientes son crs() y project(): library(terra) # Convierte de raster a terra elev_terra &lt;- rast(elev) # Transforma elev_terra_robinson &lt;- terra::project(elev_terra, terra::crs(elev_terra)) plot(elev_terra_robinson) Figura 3.19: Transformaciones en terra 3.3.3 ¿Qué proyección uso? El CRS adecuado para cada análisis depende de la localización y el rango espacial de los datos. Un CRS adecuado para representar un mapa del mundo puede no serlo para representar datos de zonas específicas de la Tierra. Los recursos web mencionados anteriormente permiten la búsqueda de CRS por zona geográfica, y adicionalmente en R existe el paquete crsuggest (Walker 2021) que nos facilita la labor, sugiriendo el CRS más adecuado para cada zona: library(crsuggest) # Usando raster sugerencias &lt;- suggest_crs(elev) Tabla 3.4: Tabla sugerencias, detalle crs_code crs_name crs_type crs_gcs crs_units crs_proj4 2062 Madrid 1870 (Madrid) / Spain LCC projected 4903 m +proj=lcc +lat_1=40 +lat_0=40 +lon_0=0 +k_0=0.9988085293 +x_0=600000 +y_0=600000 +a=6378298.3 +rf=294.73 +pm=madrid +units=m +no_defs 2154 RGF93 / Lambert-93 projected 4171 m +proj=lcc +lat_0=46.5 +lon_0=3 +lat_1=49 +lat_2=44 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 26191 Merchich / Nord Maroc projected 4261 m +proj=lcc +lat_1=33.3 +lat_0=33.3 +lon_0=-5.4 +k_0=0.999625769 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs 3944 RGF93 / CC44 projected 4171 m +proj=lcc +lat_0=44 +lon_0=3 +lat_1=43.25 +lat_2=44.75 +x_0=1700000 +y_0=3200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 3943 RGF93 / CC43 projected 4171 m +proj=lcc +lat_0=43 +lon_0=3 +lat_1=42.25 +lat_2=43.75 +x_0=1700000 +y_0=2200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 27573 NTF (Paris) / Lambert zone III projected 4807 m +proj=lcc +lat_1=44.1 +lat_0=44.1 +lon_0=0 +k_0=0.999877499 +x_0=600000 +y_0=3200000 +ellps=clrk80ign +pm=paris +towgs84=-168,-60,320,0,0,0,0 +units=m +no_defs 27572 NTF (Paris) / Lambert zone II projected 4807 m +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +ellps=clrk80ign +pm=paris +towgs84=-168,-60,320,0,0,0,0 +units=m +no_defs 27563 NTF (Paris) / Lambert Sud France projected 4807 m +proj=lcc +lat_1=44.1 +lat_0=44.1 +lon_0=0 +k_0=0.999877499 +x_0=600000 +y_0=200000 +ellps=clrk80ign +pm=paris +towgs84=-168,-60,320,0,0,0,0 +units=m +no_defs 30791 Nord Sahara 1959 / Nord Algerie projected 4307 m +proj=lcc +lat_1=36 +lat_0=36 +lon_0=2.7 +k_0=0.999625544 +x_0=500135 +y_0=300090 +a=6378249.145 +rf=293.465 +towgs84=-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547 +units=m +no_defs 30493 Voirol 1879 / Nord Algerie (ancienne) projected 4671 m +proj=lcc +lat_1=36 +lat_0=36 +lon_0=2.7 +k_0=0.999625544 +x_0=500000 +y_0=300000 +ellps=clrk80ign +units=m +no_defs # Probamos sugerencia crs_suggest &lt;- suggest_crs(elev, limit = 1) elev_suggest &lt;- projectRaster(elev, crs = raster::crs(crs_suggest$crs_proj4)) plot(elev_suggest) Figura 3.20: raster: Ejemplo de transformación usando crsuggest # Ejemplo con sf: China china &lt;- gisco_get_countries(country = &quot;China&quot;) china_crs &lt;- suggest_crs(china, limit = 1) china_crs #&gt; # A tibble: 1 x 6 #&gt; crs_code crs_name crs_type crs_gcs crs_units crs_proj4 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 4584 New Beijing / Gauss-Kruger CM 105E projected 4555 m +proj=tmerc +lat_0=0 +lo~ china_suggest &lt;- st_transform( china, st_crs(as.integer(china_crs$crs_code)) ) plot(st_geometry(china_suggest), axes = TRUE) Figura 3.21: sf: Ejemplo de transformación usando crsuggest References "],["dep-esp.html", "Capítulo 4 Estadística espacial 4.1 Antes de continuar dependencia espacial. 4.2 Datos espaciales 4.3 Clasificación de datos espaciales", " Capítulo 4 Estadística espacial La estadística espacial se basa en la suposición de que las unidades georreferenciadas cercanas están relacionadas (son dependientes) de alguna manera (Getis 1999), y por ello, trata de reconocer y aprovechar ésta ubicación espacial a la hora de diseñar, recopilar, gestionar, analizar y mostrar las observaciones (Montero et al. (2011)). Los métodos estadísticos espaciales que se utilizan actualmente, y sobre los que continúan las investigaciones, incluyen el estudio de la asociación espacial, el análisis de patrones, la escala y la zonificación, la geoestadística, la clasificación, el muestreo espacial y la econometría espacial. Estos métodos se aplican a una gran variedad de disciplinas científicas. Por ejemplo, Montero et al. (2011) destacan los siguientes. Los orígenes de la vida humana vinculan los estudios de la evolución de las galaxias, la estructura de las células biológicas y los patrones de asentamiento arqueológicos. Los ecologistas estudian las interacciones entre plantas y animales. Silvicultores y agricultores necesitan investigar las variaciones que se producen en el terreno para sus experimentos. La estimación de las precipitaciones y de las reservas de oro y petróleo es de vital importancia económica. Estos son, entre otros, buenos ejemplos de la importancia del espacio (espacio-tiempo en su caso) en el mundo de la Ciencia. Sin embargo, el estudio de la variabilidad espacial, y sobre todo espacio-temporal, es una disciplina relativamente nueva en el marco de la Estadística, lo que explica la escasez de instrumentos de estadística espacial 30 años atrás. En los últimos 10 años ha habido una creciente toma de conciencia de esta necesidad, habiéndose realizado un gran esfuerzo por buscar herramientas adecuadas y útiles a tales efectos. Y todo ello porque utilizar modelos espaciales o espacio-temporales para caracterizar y explotar la dependencia espacial (o espacio-temporal) de un conjunto de observaciones tiene importantes ventajas (Montero et al. (2011)): Modelos más generales, ya que, en la mayoría de los casos, los modelos clásicos que no tienen en consideración la dimensión espacial o la interacción de las dimensiones espacial y temporal son un caso particular de un modelo espacial o espacio-temporal. Estimaciones más eficientes: de la tendencia, de los efectos de las variables explicativas, de promedios regionales, Mejora de las predicciones: más eficientes, con propiedades de extrapolación más estables, La variación espacial no explicada en la estructura de la media debe ser absorbida por la estructura del error, por lo que un modelo que incorpore la dependencia espacial puede decirse que está protegido frente a una mala especificación de este tipo. Esto, en muchos casos, tiene como resultado una simplificación en la especificación de la tendencia; en general, los modelos con dependencia espacial suelen tener una descripción más parsimoniosa (en ocasiones con muchos menos parámetros) que los clásicos modelos de superficie de tendencia. 4.1 Antes de continuar dependencia espacial. Frecuentemente los datos tienen una componente espacial y/o temporal asociada a ellos y es de esperar que datos cercanos en el espacio o en el tiempo sean más semejantes que aquellos que están más alejados; en cuyo caso no deben ser modelados como estadísticamente independiente, sino que habrá que tomar en cuenta esa dependencia espacial o espacio-temporal. De forma natural y de acuerdo a la Ley Tobler (1973) surge la idea de que los datos cercanos en el espacio o en el tiempo serán más similares y estarán más correlacionados entres sí que aquellos que están más lejanos. Por ejemplo, la influencia de un terremoto, su efecto disminuye con distancia del epicentro. Además, esta correlación disminuye al aumentar la separación entre ellos, por lo que se puede pensar en la presencia de una dependencia espacial o espacio-temporal. Si los datos no exhiben dependencia espacial no tiene sentido aplicar las herramientas de estadística espacial. ¿Y cómo se pueden reconocer un proceso con dependencia espacial? La clave esta en que los procesos con dependencia espacial exiben un patrón en el espacio, mientras que los que son independientes son totalmente aleatorios. La Fig. 4.1 muestra uno campo aleatorio simulado que presentan una estructura de dependencia espacial (panel izquierdo) frente a unos datos totalmente aleatorios (panel derecho), en ambos casos distribuidos de forma irregular en el espacio. En la imagen de dependencia espacial se observa como los puntos rojos (que representan valores más altos de la variable simuladas) se concentran en la misma zona, al igual que los puntos azules (que representan valores más bajos) que se distribujen en otra zona y juntos. #&gt; &#39;RandomFields&#39; will use OMP Figura 4.1: Puntos: Simulación patrón de independencia espacial (derecha) frente a dependencia espacial (izquierda) La Fig. 4.2, al igual que la Fig. 4.1 presenta unos datos simulados donde que muestran una estructura de dependencia espacial (panel izquierdo) frente a unos datos totalmente aleatorios (panel derecho), pero en este caso estos datos se distribuyen de forma ordenada en el espacio a través de una rejilla regular. La interpretación es análoga a la de la Fig. 4.1, solo que en este caso los campos aleatorios simulados se representan en una rejilla. Figura 4.2: Rejilla: Simulación patrón de independencia espacial (derecha) frente a dependencia espacial (izquierda) 4.2 Datos espaciales Los datos espaciales, también conocidos como datos geoespaciales, son aquellos datos relacionados o que contienen información de una localización o área geográfica de la superficie de la Tierra. La forma más intuitiva de representar los datos espaciales es a través de un mapa. # Mapa de porcentaje de mujeres en Castilla-La Mancha library(mapSpain) # Datos de población pob &lt;- mapSpain::pobmun19 # Datos en forma de tabla, sin información en formato espacial # head(pob) # Porcentaje pob$porc_mujeres &lt;- pob$women / pob$pob19 * 100 # Datos espaciales geo &lt;- esp_get_munic(region = &quot;Castilla-La Mancha&quot;) # Estos datos tienen una columna (geometry) con coordenadas. # head(geo) # Une ambos datos geo_pob &lt;- merge(geo, pob, by = c(&quot;cpro&quot;, &quot;cmun&quot;), all.x = TRUE ) # Mapa básico plot(geo_pob[&quot;porc_mujeres&quot;], # Cambiamos titulo main = &quot;Castilla-La Mancha: % mujeres (2019)&quot;, # Cambiamos la paleta de colores para hacerlo mas atractivo # border = NA, pal = hcl.colors(12, &quot;RdYlBu&quot;) ) Figura 4.3: Porcentaje de Mujeres en Castilla-La Mancha La Fig. 4.3 presenta una serie de elementos gráficos, característicos de los objetos espaciales: Los municipios de Castilla-la Mancha están representados por polígonos con un contorno negro y se rellenan de colores de acuerdo con la variable que estamos analizando, el porcentaje de mujeres en los municipios de Castilla-La Mancha en el año 2019. Una leyenda explica el significado de los colores. La variable, el porcentaje de mujeres en los municipios de Castilla-La Mancha en el año 2019, no parece distribuirse de manera independiente sino todo lo contrario, muestra un patrón espacial. Los municipios del las provincias Guadalajara y Cuenca (noreste) presentan tasas más bajas que los municipios del centro de la Comunidad. head(geo_pob[&quot;porc_mujeres&quot;]) #&gt; Simple feature collection with 6 features and 1 field #&gt; Geometry type: POLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: -2.18037 ymin: 38.5441 xmax: -1.31112 ymax: 39.35597 #&gt; Geodetic CRS: ETRS89 #&gt; porc_mujeres geometry #&gt; 1 52.02532 POLYGON ((-1.58316 39.20446... #&gt; 2 43.93064 POLYGON ((-1.40607 39.12384... #&gt; 3 51.14089 POLYGON ((-2.0562 38.88697,... #&gt; 4 48.55491 POLYGON ((-1.54055 38.61066... #&gt; 5 48.78419 POLYGON ((-1.38514 39.35429... #&gt; 6 44.49541 POLYGON ((-2.15635 38.71074... Antes de dibujar la Fig. 4.3 tuvimos que leer los datos de la librería mapSpain (Hernangómez 2022b) que contenía tanto la variable que hemos analizado como el formato del mapa. Tras unir variable y mapa con la función merge(). Al llevar a cabo un resumen del objeto espacial nos encontramos con las siguiente información: el conjunto de datos (seleccionado) tiene 919 registros (municipios) el tipo de geometría es POLYGON. el CRS es ETRS89 4.3 Clasificación de datos espaciales Tal y como acabamos de señalar y de acuerdo con Schabenberger and Gotway (2005), p. 6), debido a que los datos espaciales surgen en una gran variedad de campos y aplicaciones, también hay una gran variedad de tipos de datos espaciales, estructuras y escenarios. Por tanto, una clasificación exhaustiva de los datos espaciales sería un reto muy difícil y hemos apostado por una clasificación general, simple y útil de datos espaciales proporcionada por Cressie (1993). La clasificación de Cressie de datos espaciales se basa en la naturaleza del dominio espacial en estudio. Dependiendo de esto, podemos tener: datos geoestadísticos, datos de patrones de puntos y datos lattice (véase Fig. 4.4 en la que se han simulado los distintos procesos espaciales). Figura 4.4: Clasificación de datos espaciales propuesta por Cressie (1993)) Siguiendo a Cressie (1993), sea \\(s  ^d\\) una localización en un espacio Euclideo \\(d-\\)dimensional y \\({Z(s) s  ^d}\\) una función aleatoria espacial, donde \\(Z\\) representa el atributo en el cual estamos interesados, se tendría la siguiente clasificación (Montero, Fernández-Avilés, and Mateu 2015): Datos geoestadísticos: Surgen cuando el dominio de estudio es continuo y fijo \\(D\\). Es decir: (i) \\(Z(s)\\) se puede observar en cualquier punto del dominio (continuo); y (ii) los puntos en \\(D\\) no son estocásticos (son fijos, \\(D\\) es el mismo para todas las realizaciones de la función aleatoria espacial). Algunos ejemplos de datos geoestadísticos son el nivel de un contaminante en una ciudad, los valores de precipitación o temperatura del aire en un país, las concentraciones de metales pesados en la capa superior del suelo de una región, etc. Es obvio que, al menos en teoría, el nivel de un contaminante específico podría medirse en cualquier lugar de la ciudad; Lo mismo puede decirse de las mediciones de precipitaciones o temperaturas del aire en un país o concentraciones de un metal pesado en una región. Sin embargo, en la práctica, no es posible una observación exhaustiva del proceso espacial. Por lo general, el proceso espacial se observa en un conjunto de ubicaciones (por ejemplo, el nivel de un contaminante específico en una ciudad se observa en los puntos donde están ubicadas las estaciones de monitoreo) y, basado en tales valores observados, el análisis geoestadístico reproduce el comportamiento de el proceso espacial en todo el dominio de interés. La Fig. 4.5 presenta un mapa de interpolación krigeado del nivel de monoxido de carbono (CO) en logaritmos para la ciudad de Madrid. En el análisis geoestadístico lo más importante es cuantificar la correlación espacial entre observaciones (a través de la herramienta básica en geoestadística, el semivariograma) y utilizar esta información para lograr los objetivos anteriores (véase Montero, Fernández-Avilés, and Mateu (2015) para un análisis profundo de los métodos geoestadísticos espaciales y espacio-temporales}. Figura 4.5: Mapa de interpolación del nivel de CO en el aire en la ciudad de Madrid Datos reticulares: Surgen cuando: (i) el dominio bajo estudio \\(D\\) es discreto, es decir, \\(Z(s)\\) puede observarse en una serie de ubicaciones fijas que pueden enumerarse. Estas ubicaciones pueden ser puntos o regiones, pero generalmente son códigos postales, pistas censales, vecindarios, provincias, países, etc., y los datos en la mayoría de los casos son datos agregados espacialmente sobre estas áreas. Aunque estas regiones pueden tener una forma regular, normalmente la forma que tienen es irregular, y esto, junto con el carácter espacialmente agregado de la datos, es por lo que los datos latice tambien se denominan datos regionales. Y (ii) las ubicaciones en \\(D\\) no son estocásticas. Por supuesto, un concepto clave en el análisis de los datos lattice es el vecindario y la matriz W. Algunos ejemplos de reticulares incluyen la tasa de desempleo por estados, los datos de delincuencia por comarcas, rendimientos agrícolas en parcelas, precios medios de la vivienda por provincias, etc. En este sentido un ejemplo ilustrativo se presenta en la la Fig. 4.6, que muestra la distribución municipal de la renta neta media por hogar en 2017 en España. Figura 4.6: Renta neta media municipal española en 2017 Procesos de puntos: Mientras que en los datos geoestadísticos y reticulares el dominio \\(D\\) es fijo, en los datos de patrones puntuales el dominio es discreto o continuo, pero aleatorio. Los patrones de puntos surgen cuando el atributo bajo estudio es la ubicación de los eventos (observaciones). Es decir, el interés radica en dónde ocurren eventos de interés. Algunos ejemplos de patrones de puntos son la ubicación de incendios en una región española, la ubicación de los árboles en un bosque o la ubicación de nidos en una colonia de aves reproductoras, la localización de los accidentes de tráfico en una ciudad o área de referencia, la localización de los delitos en una ciudad, entre muchas otras. En estos En los casos, es obvio que \\(D\\) es aleatorio y los puntos de observación no dependen del investigador. El principal objetivo del análisis de patrones de puntos es determinar si la ubicación de los eventos tiende a exhibir un patrón sistemático sobre el área en estudio o, por el contrario, son aleatoriamente repartido. Más concretamente, nos interesa analizar si la ubicación de los eventos es completamente aleatorio espacialmente (la ubicación donde ocurren los eventos no se ve afectada por la ubicación de otros eventos), uniforme o regular (cada punto está tan lejos de todos sus vecinos como sea posible) o agrupados o agregados (la ubicación de los eventos se concentra en grupos). La Fig. 4.7 muestra la localización de los accidentes de tráfico registrados en la ciudad de Madrid durante el mes de febreo de 2020. Figura 4.7: Accidentes de tráfico registrados en la ciudad de Madrid (Febrero de 2020) References "],["caos.html", "Capítulo 5 Casos prácticos 5.1 Caso 1: Temperatura mínimas del aire en España. 5.2 Caso 2. Distribución espacial de la renta media por municipios", " Capítulo 5 Casos prácticos NOTA En las siguientes aplicaciones se asumen que los datos se localizan en la carpeta data del proyecto de R-Studio en el que se esté trabajando. Los datos pueden descargarse desde esta dirección: https://github.com/mdsr-espacial/datos/raw/main/01_visualizacion/datos.zip 5.1 Caso 1: Temperatura mínimas del aire en España. Objetivo de aprendizaje Esta sección presenta un caso de uso en el que aprenderemos a realizar las siguientes tareas básicas: Leer datos espaciales en R. Proyectar datos espaciales. Graficar datos espaciales. Para ello, se va a trabajar con los datos de temperatura mínima registradas en España por las estaciones metereológicas de la Agencia Estatal de Meteorología (AEMET). Un conjuto de datos ya depurados y listos par trabajar se encuentra en el fichero tempmin.csv. Por otra parte, la información relativa al mapeo de España se obtendrá directamente de la librería mapSpain. Todo el análisis se va a realizar empleando RStudio, por lo que se empezará abriendo el programa y creando un nuevo proyecto. Ejercicio 5.1 (Creación del proyecto) Cree un proyecto para trabajar todo lo referente al caso. Solución. Para crear un proyecto siga la secuencia: File&gt; New Proyect&gt; New File&gt; RMD El conjunto de datos proporcionado tempmin.csv contiene el nivel de temperatura del aire en España entre el 6 y el 10 de Enero de 20211. Estos datos han sido descargados usando la librería climaemet (Pizarro, Hernangómez, and Fernández-Avilés 2021) y han sido posteriormente tratados para su uso en esta práctica. A continuación es necesario importar la base de datos de temperatura mínima. El archivo está en formato csv, por lo cual, es un fichero de texto plano. Se pueden usar varias funciones para realizar la importación. Se emplearán los paquetes del tidyverse (Wickham et al. 2019) para realizar todo el tratamiento de datos. Ejercicio 5.2 (Importación de los datos) Importe los datos tempmin.csv y guárdelos en un objeto llamado tmin. Solución. Use la librería readr. # Cada uno debe seleccionar el directorio donde tiene los datos, de ahí # que sea conveniente trabajar con proyectos. library(readr) tmin &lt;- read_csv(&quot;data/tempmin.csv&quot;) El conjunto de datos tempmin es un data frame que contiene 5 variables: fecha: Indicando la fecha de observación. indicativo: Es el identificador de la estación de la AEMET que registró el dato. tmin: Dato de temperatura mínima registrada en cada fecha por la estación correspondiente en grados centígrados. longitud, latitud: Coordenadas geográficas de la estación Ejercicio 5.3 (Descripción de los datos) Con la función head() describa, en forma de tabla, la información que contiene el objeto tmin y compruebe que se corresponde con la descrita. knitr::kable(head(tmin), caption = &quot;Detalle del objeto tmin&quot;) Tabla 5.1: Detalle del objeto tmin fecha indicativo tmin longitud latitud 2021-01-06 4358X -4.7 -5.880556 38.95556 2021-01-06 4220X -7.0 -4.616389 39.08861 2021-01-06 6106X 4.7 -4.748333 37.02944 2021-01-06 9698U -6.8 0.865278 42.20528 2021-01-06 4410X -3.4 -6.385556 38.91583 2021-01-06 1331A 1.0 -7.031389 43.52472 Una de las clases de objetos espaciales más utilzada en R es sf. Sin embargo, dependiendo del análisis que se quiera realizar hay otras muy comunes como geodata, spatastat, etc.. A continuación se convertirá el objeto tmin (data.frame) a un objeto de la clase geodata, una clase muy utilizada para trabajar con datos espaciales y requerida por la librería geoR (Ribeiro Jr et al. 2020). Estos objetos contienen las coordenadas y la variable objeto de estudio. Para mayor detalle ver ??as.geodata. Obsérvese como varía la variable a través de los ejes longitud y latitud. Observe tambien la forma campaniforme de la distribución de la variable. Ejercicio 5.4 (Descripción de los datos) Del objeto tmin seleccione el día 8 de enero de 2022 y las variables longitud, latitud y tmin para crear el objeto y llámelo tmin_geoR. A continuación describa analítica y gráficamente dicho objeto. library(dplyr) library(geoR) tmin_geoR &lt;- tmin %&gt;% filter(fecha == &quot;2021-01-08&quot;) %&gt;% # Seleccionamos las columnas de interés dplyr::select(longitud, latitud, tmin) %&gt;% # Y creamos el objeto geodata as.geodata( coords.col = 1:2, data.col = 3 ) summary(tmin_geoR) #&gt; Number of data points: 211 #&gt; #&gt; Coordinates summary #&gt; longitud latitud #&gt; min -9.291389 35.27639 #&gt; max 4.215556 43.78611 #&gt; #&gt; Distance summary #&gt; min max #&gt; 0.01024389 13.85144264 #&gt; #&gt; Data summary #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; -14.9000000 -4.6000000 -0.5000000 -0.6293839 3.5000000 13.6000000 plot(tmin_geoR) Figura 5.1: Convertir data.frame a geodata En esta ocasión, convertiremos los datos de tmin en un objeto espacial sf, es decir, datos espaciales de tipo vector. Los datos de tmin contienen coordenadas geográficas longitud/latitud, así que como se vió en la Sección 3.3 el CRS a emplear ha de ser un CRS geográfico. Usaremos el código EPSG:4326, que corresponde a coordenadas geográficas y suele ser el habitual en este tipo de situaciones. Ejercicio 5.5 (Convertir data.frame a sf) Del objeto tmin seleccione las variables longitud, latitud y tmin para crear el objeto sf y llámelo tmin_sf. A continuación describa el objeto creado. library(sf) tmin_sf &lt;- st_as_sf(tmin, coords = c(&quot;longitud&quot;, &quot;latitud&quot;), crs = 4326 ) tmin_sf #&gt; Simple feature collection with 1066 features and 3 fields #&gt; Geometry type: POINT #&gt; Dimension: XY #&gt; Bounding box: xmin: -9.291389 ymin: 35.27639 xmax: 4.215556 ymax: 43.78611 #&gt; Geodetic CRS: WGS 84 #&gt; # A tibble: 1,066 x 4 #&gt; fecha indicativo tmin geometry #&gt; * &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;POINT [°]&gt; #&gt; 1 2021-01-06 4358X -4.7 (-5.880556 38.95556) #&gt; 2 2021-01-06 4220X -7 (-4.616389 39.08861) #&gt; 3 2021-01-06 6106X 4.7 (-4.748333 37.02944) #&gt; 4 2021-01-06 9698U -6.8 (0.865278 42.20528) #&gt; 5 2021-01-06 4410X -3.4 (-6.385556 38.91583) #&gt; 6 2021-01-06 1331A 1 (-7.031389 43.52472) #&gt; 7 2021-01-06 1690A -0.1 (-7.859722 42.32528) #&gt; 8 2021-01-06 8489X -8 (-0.255833 40.43333) #&gt; 9 2021-01-06 8025 2 (-0.494167 38.3725) #&gt; 10 2021-01-06 9784P -10 (0.224722 42.63) #&gt; # ... with 1,056 more rows La siguiente tarea será representar las estaciones que monitorizan la temperatura mínima en un mapa de España. Ejercicio 5.6 (Reprsentación espacial de la clase sf) Represente un mapa de España, con las Comunidades Autónomas de incluidas, excepto las Islas Canarias (por simplicidad) Solución. Una opción es utilizar un paquete API que nos proporciona esta información en formato sf, el paquete mapSpain. library(mapSpain) # sf object esp &lt;- esp_get_ccaa() %&gt;% # No vamos a usar Canarias en este análisis filter(ine.ccaa.name != &quot;Canarias&quot;) plot(esp$geometry) # Dibujamos el mapa de España menos las Islas Canarias Figura 5.2: Mapa de España (Sin Canarias) Como se comentó en la Sección 3.3, cuando se emplean datos geográficos provenientes de varias fuentes, es necesario asegurarse de que ambos objetos están usando el mismo CRS. Ejercicio 5.7 (CRS) ¿Tengo el Sistema de referencia de coordenadas (CRS) de las estaciones de monitoreo en la misma proyección que el contorno de España? Compruebelo. st_crs(tmin_sf) == st_crs(esp) #&gt; [1] FALSE Se ha comprobado que no lo están, por lo que hay que proyectar las coordenadas a un CRS común. Ejercicio 5.8 (CRS) Proyecte las coordenadas de los objetos tmin_sf y esp al CRS de referencia de tmin_sf. Compruébelo. esp2 &lt;- st_transform(esp, st_crs(tmin_sf)) st_crs(tmin_sf) == st_crs(esp2) #&gt; [1] TRUE Para dibujar las estaciones de monitoreo con el contorno de España, existen varias opciones de paquetes, ggplot2 (Wickham 2016) (paquete de referencia en representaciones gráficas), tmap (Tennekes 2018) o mapsf (Giraud 2022) (estos dos últimos especializados en mapas temáticos). Ejercicio 5.9 (CRS) Represente, con el paquete ggplot2, las estaciones de monitorero de AEMET en la Península Ibérica. library(ggplot2) ggplot(esp2) + # Para graficar objetos sf debemos usar geom_sf() geom_sf() + geom_sf(data = tmin_sf) + theme_light() + theme( plot.title = element_text( size = 12, face = &quot;bold&quot; ), plot.subtitle = element_text( size = 8, face = &quot;italic&quot; ) ) Figura 5.3: Estaciones de AEMET en la Península Ibérica Una vez represtadas las coordenadas, es decir, las estaciones de monitoreo dónde se ha medido la variable temperatura mínima tmin, el siguiente paso será representar el valor que toma la variable en esas coodenadas. La base tmin contiene información temporal para para varios días, por lo que, como este análisis es meramente espacial se elegirá un día que se fijará para todo el análisis. Ejercicio 5.10 (plot-sp1) Representamos la variable temperatura mínima tmin para el día 8 de enero de 2021. Guarde la base de datos espacial para ese día en un objeto de nombre tmin_8enero. # Seleccionaremos los datos correspondientes al 8 de enero de 2021 tmin_8enero &lt;- tmin_sf %&gt;% filter(fecha == &quot;2021-01-08&quot;) # Mapa temático en el que se representan los valores de temperatura mínima # registrados en cada estación mediante un código de colores plot(tmin_8enero[&quot;tmin&quot;], pch = 8 ) Figura 5.4: Mapa de puntos con temperatura mínima (8-enero-2021) El mapa ha quedado muy bien, pero quizá los colores y el formato elegido no sean los más adecuados para este tipo de representaciones Ejercicio 5.11 (plot-sp2) Utilice los parámetros espaciales de los que dispone, las coordenadas y el contorno de España para graficar y contar la historia de Filomena adecuadamente. Figura 5.5: Mapa completo con temperatura mínima (8-enero-2021) La visión que ofrece el la Fig. 5.5 de Filomena es muy informativa, vemos como los datos nos cuentan la historia de lo que ocurrió ese día. La pena es que no existan estaciones de monitoreo en todos los puntos de España para conocer el valor de la temperatura mínima en cualquier lugar del país. ¿Podríamos tener un mapa de interpolación para tener una estimación de la temperatura mínima en las partes donde la AEMET no tiene estación de monitoreo? Tal y como se avanzó en el Capítulo 4, parece lógico pensar que aquellos puntos que estén cerca tendrán valores similares. Por tanto, tomemos ventaja de las propiedades de la dependencia espacial y utilicemos un método de interpolación sencillo, en este caso un método determinista, la Distancia Inversa Ponderada, comúnmente conocido por su acrónimo inglés IDW (Inverse distance weighted), el cual es uno de los métodos más simples para llevar para llevar a cabo una interpolación espacial. En este tipo de análisis espacial, es crucial que el CRS sea el apropiado. En este caso, ya se definió el CRS como un CRS geográfico (es decir, usando coordenadas de longitud y latitud). Sin embargo, para el ejercicio de interpolación es más adecuado usar un CRS local (que provoca pocas deformaciones en la proyección de España) y en alguna unidad de distancia, como metros (ya se vio en la Sección 3.3 que en los CRS geográficos las unidades son grados). Ejercicio 5.12 (Obtención de CRS sugerido para un conjuto de datos) Utilice el paquete crsuggest para observar los CRS sugeridos y, si es necesario, transforme la proyección de los datos. library(crsuggest) sugiere &lt;- suggest_crs(tmin_8enero, units = &quot;m&quot;, limit = 5) # Usamos la sugerencia del paquete crs_sugerido &lt;- st_crs(sugiere[1, ]$crs_proj4) # Madrid esp3 &lt;- st_transform(esp2, crs_sugerido) tmin_8enero3 &lt;- st_transform(tmin_8enero, crs_sugerido) Una vez solucionado el problema de las proyecciones, antes de llevar a cabo la interpolación, es necesario generar una malla que representará las celdas de las que queremos obtener el valor interpolado. Dado que hemos proyectado nuestros datos a un CRS cuya unidad son los metros, podemos definir el tamaño de cada celda en metros cuadrados. En este caso vamos a usar celdas de 100 kms cuadrados (10 x 10 kms). Ejercicio 5.13 (Creación y representación de una malla de interpolación) Genere un grid y llámelo malla_sf (puede fijar una semilla si lo desea) y grafíque la superficie construida. # Generación de la superficie a interpolar set.seed(9876) # Aseguramos que el grid generado siempre es igual malla_sf &lt;- st_make_grid( esp3, cellsize = 10000 ) # Representación de la superficie construida añadiendo el contorno de España ggplot(esp3) + geom_sf() + geom_sf( data = malla_sf, size = 0.1, col = &quot;red&quot;, alpha = 1, fill = NA ) + geom_sf( data = tmin_8enero3, aes(fill = &quot;AEMET Stations&quot;), size = 4, shape = 21, color = &quot;blue&quot; ) + scale_fill_manual(values = adjustcolor(&quot;blue&quot;, alpha.f = 0.2)) + theme_void() + theme(legend.position = &quot;bottom&quot;) Figura 5.6: Malla de puntos para interpolación Se puede observar claramente cada una de las celdas que se han creado. La interpolación asignará un valor a cada uno de ellas. A continuación podemos llevar a cabo la interpolación usando el paquete gstat (Pebesma 2004). Además, en lugar de celdas (polígonos) es necesario usar puntos en la interpolación. Calcularemos, por tanto, un punto representativo de cada celda creada en la superficie anterior malla_sf, el centroide, que es el punto resultante de realizar la media arimética de las coordenadas de los puntos que componen los lados de cada celda. Ejercicio 5.14 (Interpolación a través de la Distancia Inversa Ponderada) Calcule los centroides de los polígonos de la malla construida en el Ejercicio 5.13 con la función st_centroid() y realice una interpolación de la variable temperatura mínima tmin para el día 8 de enero de 2021 con el método IDW usando la librería gstat y la función idw. Guarde el resultado obtenido en un objeto llamado tmin_idw. Utilice la función help(idw) si requiere información sobre cómo introducir los parámetros en la función. Examine la información del objeto tmin_idw, a través de la función head(), # Calculamos una malla con centroides malla_sf_cent &lt;- st_centroid(malla_sf, of_largest_polygon = TRUE) library(gstat) tmin_idw &lt;- idw( # Indicamos la variable que queremos interpolar tmin ~ 1, # Indicamos el conjunto de datos donde está la variable tmin_8enero3, # Indicamos la malla de destino, en sf newdata = malla_sf_cent, idp = 2.0 # Especifica la potencia de la IDW ) #&gt; [inverse distance weighted interpolation] head(tmin_idw) #&gt; Simple feature collection with 6 features and 2 fields #&gt; Geometry type: POINT #&gt; Dimension: XY #&gt; Bounding box: xmin: 147290.9 ymin: 70457.31 xmax: 197290.9 ymax: 70457.31 #&gt; CRS: +proj=lcc +lat_1=40 +lat_0=40 +lon_0=0 +k_0=0.9988085293 +x_0=600000 +y_0=600000 +a=6378298.3 +rf=294.73 +pm=madrid +units=m +no_defs #&gt; var1.pred var1.var geometry #&gt; 1 2.529082 NA POINT (147290.9 70457.31) #&gt; 2 2.615255 NA POINT (157290.9 70457.31) #&gt; 3 2.703976 NA POINT (167290.9 70457.31) #&gt; 4 2.795295 NA POINT (177290.9 70457.31) #&gt; 5 2.889262 NA POINT (187290.9 70457.31) #&gt; 6 2.985925 NA POINT (197290.9 70457.31) Un tipo de mapas muy utilizado cuando se trabaja con datos espaciales son los mapas de contorno. Es muy visual y ayuda a interpretar el mapa interpolado, añadir unas lineas de contorno al mapa interpolado. Ejercicio 5.15 (Mapa de interpolación y contorno con raster) Represente los valores interpolados, tmin_idw, y añada unas lineas de contorno. Utilice el paquete raster para convertir el objeto interpolado a pixeles. # Convertimos de sf a SpatiaPixels # Esto funciona porque nuestros puntos sf están espaciados regularmente tmin_pixels &lt;- tmin_idw %&gt;% as(&quot;Spatial&quot;) %&gt;% as(&quot;SpatialPixels&quot;) library(raster) # Creamos un raster de nuestros pixels rast_esp &lt;- raster(tmin_pixels) # Transferimos valores del objeto sf al raster rast_esp2 &lt;- rasterize( tmin_idw, rast_esp, field = &quot;var1.pred&quot;, ## valores de predicción idw fun = mean ) # Además, podemos recortar el raster a la forma de España rast_esp_mask &lt;- mask(rast_esp2, esp3) plot(rast_esp_mask, col = colores) contour(rast_esp2, add = TRUE) Figura 5.7: Mapa raster con lineas de nivel Ejercicio 5.16 (Mapa de interpolación con `ggplot`) Repita el mapa de 5.15 usando ggplot2 y la función geom_contour_filled(). # Creo una tabla para geom contour coordenadas &lt;- st_coordinates(tmin_idw) valor &lt;- tmin_idw$var1.pred idw_df &lt;- data.frame( # Necesitamos redondear las coordenadas latitud = round(coordenadas[, 2], 6), longitud = round(coordenadas[, 1], 6), tmin = valor ) ggplot() + geom_contour_filled( data = idw_df, aes(x = longitud, y = latitud, z = tmin), na.rm = TRUE, breaks = cortes ) + # Reajustamos la escala de colores scale_fill_manual(values = colores) + # CCAA geom_sf(data = esp3, fill = NA) + theme_minimal() + theme(axis.title = element_blank()) + labs( fill = &quot;Temp. (º)&quot; ) Figura 5.8: Temperatura mínima interpolada. 8 de Enero 2021. 5.2 Caso 2. Distribución espacial de la renta media por municipios Objetivos de aprendizaje Esta sección presenta un caso de uso en el que aprenderemos a realizar las siguientes tareas básicas: Importar datos tabulares y datos espaciales. Realizar un tratamiento de limpieza de datos y cruzar tablas. Hacer mapas temáticos. Aprenderemos también algunas nociones básicas sobre cómo crear diferentes clases para un conjunto de datos continuo. Para ello, partiremos de dos ficheros: Fichero renta_municipio.csv: Este fichero contiene información de la Renta Neta per cápita por municipios (en euros), distritos y secciones censales. Esta información se ha extraído del Atlas de distribución de renta de los hogares proporcionado por el INE, y ha sido tratado previamente para adaptar la información al presente ejercicio. Fichero municipios.gpkg: Es un fichero que contiene datos espaciales (polígonos) de los municipios en España en el año 2019. Se ha extraído del Instituto Geográfico Nacional (IGN) usando el paquete mapSpain. El primer paso en cualquier tipo de análisis de datos es importar los datos al software de tratamiento (en nuestro caso, R) y analizarlos para conocer el tipo de información que contiene. Ejercicio 5.17 (Importación y análisis del los datos objeto de estudio) Importe el fichero de datos renta_municipio.csv y municipios.gpkg y guárdelo en un objeto llamado renta y munis, respectivamente. Observe la información que contienen. Puede ayudarse de la función head. Use las librerías oportunas para importar los datos en los distintos formatos. # Usaremos paquetes del tidyverse library(dplyr) library(readr) renta &lt;- read_csv(&quot;data/renta_municipio.csv&quot;, na = &quot;.&quot;) library(sf) munis &lt;- st_read(&quot;data/municipios.gpkg&quot;, quiet = TRUE) head(renta) #&gt; # A tibble: 6 x 6 #&gt; Unidad `2019` `2018` `2017` `2016` `2015` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 44001 Ababuj NA NA NA NA NA #&gt; 2 4400101 Ababuj distrito 01 NA NA NA NA NA #&gt; 3 4400101001 Ababuj sección 01001 NA NA NA NA NA #&gt; 4 40001 Abades 11429 10731 10314 9816 9904 #&gt; 5 4000101 Abades distrito 01 11429 10731 10314 9816 9904 #&gt; 6 4000101001 Abades sección 01001 11429 10731 10314 9816 9904 Se puede comprobar que tenemos información para el periodo 2015-2019. Además, la columna Unidad contiene un literal con el municipio o sección correspondiente. head(munis) #&gt; Simple feature collection with 6 features and 7 fields #&gt; Geometry type: MULTIPOLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: -3.140179 ymin: 36.73817 xmax: -2.057058 ymax: 37.54579 #&gt; Geodetic CRS: ETRS89 #&gt; codauto ine.ccaa.name cpro ine.prov.name cmun name LAU_CODE geom #&gt; 1 01 Andalucía 04 Almería 001 Abla 04001 MULTIPOLYGON (((-2.775594 3... #&gt; 2 01 Andalucía 04 Almería 002 Abrucena 04002 MULTIPOLYGON (((-2.787566 3... #&gt; 3 01 Andalucía 04 Almería 003 Adra 04003 MULTIPOLYGON (((-3.051988 3... #&gt; 4 01 Andalucía 04 Almería 004 Albanchez 04004 MULTIPOLYGON (((-2.181086 3... #&gt; 5 01 Andalucía 04 Almería 005 Alboloduy 04005 MULTIPOLYGON (((-2.572442 3... #&gt; 6 01 Andalucía 04 Almería 006 Albox 04006 MULTIPOLYGON (((-2.128106 3... El objeto munis contiene polígonos y varias columnas, entre ellas dos especialmente relevantes: cpro y cmun, que corresponden a los códigos de provincia y de municipio respectivamente. Podemos comprobar que este código también se encuentra en el dataset renta. Ejercicio 5.18 (Comprobación de campos en común para un municipio: Noblejas) Para comprobar que efectivamente disponemos de dos campos en común en los ficheros, que serán de vital importancia para posteriormente unirlos, se selecciona un municipio al azar, el municipio de Noblejas en la provincia de Toledo y comprobamos. # Miro un municipio: Noblejas renta[grep(&quot;Noblejas&quot;, renta$Unidad), ] #&gt; # A tibble: 5 x 6 #&gt; Unidad `2019` `2018` `2017` `2016` `2015` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 45115 Noblejas 10591 10314 9751 9484 9124 #&gt; 2 4511501 Noblejas distrito 01 11039 10717 10135 9711 9386 #&gt; 3 4511501001 Noblejas sección 01001 11039 10717 10135 9711 9386 #&gt; 4 4511502 Noblejas distrito 02 10276 10029 9475 9319 8938 #&gt; 5 4511502001 Noblejas sección 02001 10276 10029 9475 9319 8938 munis[grep(&quot;Noblejas&quot;, munis$name), c(&quot;name&quot;, &quot;cpro&quot;, &quot;cmun&quot;)] #&gt; Simple feature collection with 1 feature and 3 fields #&gt; Geometry type: MULTIPOLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: -3.489824 ymin: 39.93003 xmax: -3.372611 ymax: 40.05017 #&gt; Geodetic CRS: ETRS89 #&gt; name cpro cmun geom #&gt; 4985 Noblejas 45 115 MULTIPOLYGON (((-3.44681 40... En el caso de Noblejas, el código completo es 45115. Sin embargo, en el caso de la tabla renta, debemos extraer ese valor del literal. Para ello debemos manipular la columna y extraer la primera palabra de la columna Unidad: # Creo una función y la aplico a toda la columna extrae_codigo &lt;- function(x) { unlist(strsplit(x, &quot; &quot;))[1] } renta$codigo_ine &lt;- sapply(as.character(renta$Unidad), extrae_codigo) head(renta[c(&quot;Unidad&quot;, &quot;codigo_ine&quot;)]) #&gt; # A tibble: 6 x 2 #&gt; Unidad codigo_ine #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 44001 Ababuj 44001 #&gt; 2 4400101 Ababuj distrito 01 4400101 #&gt; 3 4400101001 Ababuj sección 01001 4400101001 #&gt; 4 40001 Abades 40001 #&gt; 5 4000101 Abades distrito 01 4000101 #&gt; 6 4000101001 Abades sección 01001 4000101001 Ahora, es necesario crear la misma variable en munis para poder realizar el cruce: munis$codigo_ine &lt;- paste0(munis$cpro, munis$cmun) head(munis[, c(&quot;name&quot;, &quot;codigo_ine&quot;)]) #&gt; Simple feature collection with 6 features and 2 fields #&gt; Geometry type: MULTIPOLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: -3.140179 ymin: 36.73817 xmax: -2.057058 ymax: 37.54579 #&gt; Geodetic CRS: ETRS89 #&gt; name codigo_ine geom #&gt; 1 Abla 04001 MULTIPOLYGON (((-2.775594 3... #&gt; 2 Abrucena 04002 MULTIPOLYGON (((-2.787566 3... #&gt; 3 Adra 04003 MULTIPOLYGON (((-3.051988 3... #&gt; 4 Albanchez 04004 MULTIPOLYGON (((-2.181086 3... #&gt; 5 Alboloduy 04005 MULTIPOLYGON (((-2.572442 3... #&gt; 6 Albox 04006 MULTIPOLYGON (((-2.128106 3... Ya estamos listos para realizar el cruce. Además, seleccionaremos sólo las columnas que vamos a usar, en este caso la del año 2019. Ejercicio 5.19 (Unión de objetos renta y mapas) Realice la unión de los objetos con la función left_join() y seleccione las variables name, cpro, cmun, 2019. Guarde el resultado obtenido en un nuevo objeto llamado munis_renta. munis_renta &lt;- munis %&gt;% left_join(renta) %&gt;% dplyr::select(name, cpro, cmun, `2019`) Cuando crucemos datos espaciales con datos no espaciales en R, es importante que el primer dataset sea el que contiene los datos espaciales. Esto es así porque el objeto resultante hereda la clase del primer objeto. A modo de ejemplo, si realizáramos el proceso poniendo los datos espaciales en el lado derecho del join, los datos finales no serán espaciales: # Miramos la clase de munis_renta class(munis_renta) #&gt; [1] &quot;sf&quot; &quot;data.frame&quot; # Es un sf, por tanto espacial # ¿Que pasa si realizamos el cruce de la otra manera? renta %&gt;% left_join(munis) %&gt;% dplyr::select(name, cpro, cmun, `2019`) %&gt;% class() #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; El resultado es un tibble o data.frame, ¡pero no es espacial! Una vez que tenemos los datos unidos podemos realizar algunos análisis básicos, como la realización de un histograma. Ejercicio 5.20 (Histograma de la variable Renta neta media por persona ()) A través de un histograma represente la distribución de la variable Renta neta media por persona del objeto munis_renta para el año 2019. library(ggplot2) munis_renta %&gt;% ggplot(aes(x = `2019`)) + geom_histogram(color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;) + scale_x_continuous(labels = scales::label_number_auto()) + scale_y_continuous(labels = scales::label_percent()) + labs( y = &quot;&quot;, x = &quot;Renta neta media por persona ()&quot; ) Figura 5.9: Histograma de la variable Renta neta media por persona () en 2019 Se puede observar que la renta presenta una distribución Gamma con un gran número de municipios concentrados en zonas medias de renta y pocos municipios en tramos de rentas altas. Como se verá en el Ejercicio XXX (GEMA?), esta distribución va a afectar a la información que transmite el mapa. Ejercicio 5.21 (Mapa de coropletas de la distribución de la renta) Realice un mapa de coropletas mostrando la distribución de la renta usando los valores brutos de renta sin modificar ggplot(munis_renta) + # Usamos geom_sf, y como aes() lo que queremos mostrar, en este caso, el # color del polígono representa la renta. Vamos a retirar los bordes con # color = NA geom_sf(aes(fill = `2019`), color = NA) + theme_minimal() + scale_fill_continuous(labels = scales::label_number( big.mark = &quot;.&quot;, decimal.mark = &quot;,&quot;, suffix = &quot; &quot; )) + theme_minimal() Figura 5.10: Renta neta media por persona en España (2019) Este primer mapa no es demasiado informativo, por los siguientes motivos: Existe una serie de municipios para los que no tenemos datos. La escala de color no es la más adecuada. Dada la distribución de los datos, puede ser adecuado crear grupos de renta para que el mapa sea más interpretable. Ejercicio 5.22 (Adecuacion de los datos al la visualización) Elimine los municipios sin datos y a cambie la escala de color para ver si mejora la visualización de la variable Renta neta media por persona. munis_renta_clean &lt;- munis_renta %&gt;% filter(!is.na(`2019`)) ggplot(munis_renta_clean) + geom_sf(aes(fill = `2019`), color = NA) + # Cambiamos la paleta de colores, vamos a usar una paleta denominada Inferno, # ya incluida en base R con hcl.colors # Como son datos continuos, puedo usar Inferno scale_fill_gradientn( colours = hcl.colors(20, &quot;Inferno&quot;, rev = TRUE), labels = scales::label_number( big.mark = &quot;.&quot;, decimal.mark = &quot;,&quot;, suffix = &quot; &quot; ) ) + theme_minimal() Figura 5.11: Renta neta media por persona en España (2019) Este mapa proporciona algo más de información, y parece intuirse que las rentas más altas se encuentran en zonas de País Vasco, Madrid y Cataluña. Sin embargo, el hecho de que la distribución de los datos no sea normal está afectando a la visualización. Para intentar atajar este problema, se puede dividir los datos en clases, por ejemplo, cuartiles o deciles. Existen varios métodos de clasificación de datos, que en R se encuentran implementados en el paquete classInt (Bivand 2020). A continuación se van a plantear diversos métodos de clasificación y se observará cómo la historia que cuenta el mapa varía en función de dichas clases. Se proponen siguientes métodos de clasificación: El método de deciles: consiste en crear 10 categorías incluyendo el mismo número de registros en cada una de ellas. El método de intervalos equivalentes: divide el rango de valores en un número de grupos definido. La distancia de todos los intervalos es idéntica, por lo que este método no tiene en cuenta la distribución de los registros. El método de Fisher-Jenks: desarrollado específicamente para la clasificación de datos espaciales y su visualización en mapas. Produce agrupaciones de tal manera que los datos de cada grupo son cercanas entre sí y sustancialmente distintas de los valores de otros grupos. Ejercicio 5.23 (División de los datos en clases) Utilice la función classIntervals() del paquete classInt y cambie el parámetro style para obtener los métodos de clasificación: Deciles, tramos de Renta equidistantes y Fisher and Jenks. Realice un plot de las clases obtenidas y compárelas. library(classInt) # División en deciles deciles &lt;- classIntervals(munis_renta_clean$`2019`, style = &quot;quantile&quot;, n = 10 ) deciles #&gt; style: quantile #&gt; [5898,8935.6) [8935.6,9662.2) [9662.2,10352.8) [10352.8,10918) [10918,11462) #&gt; 656 656 655 654 655 #&gt; [11462,11998.6) [11998.6,12651.4) [12651.4,13475.8) [13475.8,14618.4) [14618.4,26367] #&gt; 658 656 655 656 656 plot(deciles, pal = hcl.colors(20, &quot;Inferno&quot;), main = &quot;Deciles&quot;) # Tramos equidistantes en términos de renta equal &lt;- classIntervals(munis_renta_clean$`2019`, style = &quot;equal&quot;, n = 10 ) equal #&gt; style: equal #&gt; [5898,7944.9) [7944.9,9991.8) [9991.8,12038.7) [12038.7,14085.6) [14085.6,16132.5) #&gt; 103 1510 2374 1637 702 #&gt; [16132.5,18179.4) [18179.4,20226.3) [20226.3,22273.2) [22273.2,24320.1) [24320.1,26367] #&gt; 161 52 14 3 1 plot(equal, pal = hcl.colors(20, &quot;Inferno&quot;), main = &quot;Equidistantes&quot;) fisher &lt;- classIntervals(munis_renta_clean$`2019`, style = &quot;fisher&quot;, # Fuerzo para mejorar la comparación entre métodos n = 10 ) fisher #&gt; style: fisher #&gt; [5898,8743) [8743,9770.5) [9770.5,10754) [10754,11689) [11689,12668) #&gt; 505 904 1005 1159 1032 #&gt; [12668,13803) [13803,15222.5) [15222.5,17196.5) [17196.5,20063.5) [20063.5,26367] #&gt; 874 651 305 103 19 plot(fisher, pal = hcl.colors(20, &quot;Inferno&quot;), main = &quot;Fisher-Jenks&quot; ) Se puede observar lo siguiente: El último decil de renta se corresponde a un rango de entre 15.000 y 25.000 . El método por deciles proporciona unos grupos con valores de renta muy parecidos entre sí en los valores medios. Esto es debido a la propia distribución de la variable. El método de rangos equidistantes proporciona algunos grupos con un número muy reducido de municipios. El método de Fisher-Jenks puede proporcionar unas clases con unos rangos más apropiados para los tramos altos de renta. Ejercicio 5.24 (Representación de los mapas según las clases obtenidas) Realice tres mapas distintos, creando clases de renta según cada uno de los métodos anteriormente mostrados y coméntelos. Deciles # Extracción de los valores de corte breaks_d &lt;- deciles$brks # Creación de etiquetas básicas para cada clase # Creación de una función específica para crear etiquetas formateadas label_fun &lt;- function(x) { l &lt;- length(x) eur &lt;- paste0(prettyNum(round(x, 0), decimal.mark = &quot;,&quot;, big.mark = &quot;.&quot; ), &quot; &quot;) labels &lt;- paste(eur[-l], &quot;-&quot;, eur[-1]) labels[1] &lt;- paste(&quot;&lt;&quot;, eur[1]) labels[l - 1] &lt;- paste(&quot;&gt;&quot;, eur[l - 1]) return(labels) } labels_d &lt;- label_fun(breaks_d) munis_renta_clean$Deciles &lt;- cut(munis_renta_clean$`2019`, breaks = breaks_d, labels = labels_d, include.lowest = TRUE ) ggplot(munis_renta_clean) + # Cambio la variable a representar para crear el mapa geom_sf(aes(fill = Deciles), color = NA) + # Cambio el scale, ya no es continua scale_fill_manual(values = hcl.colors(length(labels_d), &quot;Inferno&quot;, rev = TRUE )) + theme_minimal() Figura 5.12: Mapa por deciles de renta media por persona (2019) El mapa de la Fig. 5.12 ya permite observar patrones geográficos, donde se ve una clara diferencia entre la Comunidades Autónomas del Norte y las del Sur. Veamos una representación distina usando otras clases diferentes breaks_e &lt;- equal$brks labels_e &lt;- label_fun(breaks_e) munis_renta_clean$Equal &lt;- cut(munis_renta_clean$`2019`, breaks = breaks_e, labels = labels_e, include.lowest = TRUE ) ggplot(munis_renta_clean) + # Cambiamos la variable que usamos para crear el mapa geom_sf(aes(fill = Equal), color = NA) + scale_fill_manual(values = hcl.colors(length(labels_e), &quot;Inferno&quot;, rev = TRUE )) + theme_minimal() Figura 5.13: Mapa por tramos de renta equidistantes de renta media por persona (2019) El mapa de la Fig. 5.12, sin embargo, se parece más al mapa de la Fig. 5.11 con los datos sin clasificar, donde el peso visual se concentra más bien en los municipios con rentas mucho más altas que el resto (por encima de 18.000 ). Véase a continuación el mismo mapa usando la clasificación Fisher-Jenks: breaks_f &lt;- fisher$brks labels_f &lt;- label_fun(breaks_f) munis_renta_clean$`Fisher-Jenks` &lt;- cut(munis_renta_clean$`2019`, breaks = breaks_f, labels = labels_f, include.lowest = TRUE ) ggplot(munis_renta_clean) + # Cambiamos la variable que usamos para crear el mapa geom_sf(aes(fill = `Fisher-Jenks`), color = NA) + scale_fill_manual(values = hcl.colors(length(labels_f), &quot;Inferno&quot;, rev = TRUE )) + theme_minimal() Figura 5.14: Mapa por tramos según Fisher-Jenks En el mapa de la Fig. 5.14 se puede observar de una manera más clara un cluster adicional de renta en la zona de Asturias y el norte de León. Además, gracias a la escala de colores puede intuirse que este clúster de renta no presenta valores tan altos como los observados en País Vasco o Madrid. En conclusión, en el momento de realizar una visualización de datos es importante conocer el dato a representar, así como entender algunas propiedades básicas de la distribución subyacente. También se ha podido observar que hay ciertas decisiones estéticas (datos continuos vs. agrupados, escala de colores) que tienen una influencia significativa en cómo se percibe la información representada. Es responsabilidad del investigador encargado de crear de la visualización el conocer todos estos factores y aplicarlos de manera conveniente. References "],["referencias.html", "Referencias", " Referencias "],["crsproy.html", "Anexo A Tipos de CRS proyectados A.1 Por tipo de superficie de proyección A.2 Por métrica a preservar", " Anexo A Tipos de CRS proyectados Existen varias familias de proyecciones, que se pueden clasificar de diversas maneras: por tipo de superficie de proyección y por métrica a preservar. A.1 Por tipo de superficie de proyección El proceso de trasladar puntos de una esfera a un plano puede plantearse de manera práctica como el ejercicio de envolver una esfera con una superificie plana (como una hoja de papel) y trasladar los puntos de la esfera de manera lineal al punto de la superficie plana más cercano a ella. La Fig. A.1 muestra estos tres tipos de proyección. Figura A.1: Tipos de proyección por superficie de proyección A partir de este ejercicio, se plantean tres posibles soluciones (cilíndrica, cónica y acimutal o planar), dependiendo del tipo de superficie que se use para proyectar. Proyecciones cilíndricas: Son aquellas proyecciones donde la superficie de proyección conforma un cilindro alrededor de la Tierra. Una de las proyecciones cilíndricas más conocidas es la proyección de Mercator (Ver Fig. A.2). Figura A.2: Proyección Mercator Proyecciones cónicas: En este tipo de proyecciones, se plantea la superficie de proyección como una forma cónica. Como ejemplo, la proyección cónica equiáreas de Albers es una de las proyecciones que más suele usarse en la representación de mapas de América del Norte (Ver Fig. A.3). Figura A.3: Proyección cónica equiáreas de Albers Proyecciones acimutales o planares: En este tipo de proyección se proyecta una porción de la Tierra sobre un plano que es tangente a la misma en el punto de referencia. Como ejemplos de proyecciones acimutales podemos destacar la proyección ortográfica (Ver Fig. A.4). Figura A.4: Proyección ortogonal A.2 Por métrica a preservar Es importante tener en cuenta que cualquier proyección de la superficie de la Tierra produce distorsiones en una o varias características geográficas. Como ejemplo clásico, la proyección de Mercator produce distorsiones del tamaño especialmente en aquellas regiones más cercanas a los polos (Groenlandia, que la proyección de Mercator presenta una área similar a la de África, tiene menor superficie real que Argelia). Otras de las métricas que suele verse distorsionada son la distancia entre dos puntos geográficos, la dirección o la forma de regiones de la Tierra. A lo largo de la Historia se han desarrollado diversas proyecciones cuyo objetivo es preservar alguna o varias de las propiedades mencionadas anteriormente, sin embargo es importante destacar que no existe una proyección que sea capaz de preservar todas las métricas a la vez. Según la metrica a presevar, las proyecciones se pueden clasificar en: Proyecciones conformales: Intentan preservar los ángulos que se forman en la superficie terrestre. Por ejemplo, la proyección de Mercator representa ángulos rectos en las intersecciones de los paralelos y los meridianos (Ver Fig. A.5). Figura A.5: Ejemplo de proyección conformal: Mercator Proyecciones equivalentes: Preservan las proporciones de las áreas, provocando a su vez deformaciones en el resto de características, como la forma o los ángulos. La proyección acimutal equivalente de Lambers es un tipo de proyección equivalente (Ver Fig. A.6). Figura A.6: Ejemplo de proyección equivalente: Proyección acimutal equivalente de Lambers Proyecciones equidistantes: Preservan la distancia entre dos puntos geográficos específicos. Por ejemplo, la proyección Plate carré preserva la distancia entre el Polo Norte y el Polo Sur (Ver Fig. A.7). Figura A.7: Ejemplo de proyección equidistante: Platé carre Proyecciones de compromiso: No intentan preservar ninguna métrica en concreto. En su lugar, se centran en intentar encontrar un equilibrio entre las diversas distorsiones que provocan para intentar dar una representación más o menos representativa de la superficie terrestre. La proyección de Winkel Tripel, usada en los mapas de National Geographic, es un ejemplo de proyección de compromiso (Ver Fig. A.8). Figura A.8: Ejemplo de proyección de compromiso: Winkel Tripel En los anteriores ejemplos se ha añadido a cada proyección la indicatriz de Tissot. Ésta consiste en una serie de círculos imaginarios de igual área distribuidos sobre la superficie esférica de la Tierra en determinados puntos. De este manera, al presentar la indicatriz de Tissot en una proyección específica, se puede entender de una manera intuitiva la distorsión provocada por dicha proyección, ya que los círculos se ven distorsionados o preservados según los parámetros y la naturaleza de la proyección en cuestión. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
