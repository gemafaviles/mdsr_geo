# Casos prácticos {#caos}

::: {.infobox data-latex=""}
**NOTA**

En las siguientes aplicaciones se asumen que los datos se localizan en la
carpeta `data` del proyecto de R-Studio en el que se esté trabajando.

Los datos pueden descargarse desde esta dirección:

<https://github.com/mdsr-espacial/datos/raw/main/01_visualizacion/datos.zip>
:::

## Caso 1: Temperatura mínimas del aire en España.

**Objetivo de aprendizaje**

Esta sección presenta un caso de uso en el que aprenderemos a realizar las
siguientes tareas básicas:

1.  Leer datos espaciales en R.

2.  Proyectar datos espaciales.

3.  Graficar datos espaciales.

Para ello, se va a trabajar con los datos de temperatura mínima registradas en
España por las estaciones metereológicas de la Agencia Estatal de Meteorología
(AEMET). Un conjuto de datos ya depurados y listos par trabajar se encuentra en
el fichero `tempmin.csv`. Por otra parte, la información relativa al mapeo de
España se obtendrá directamente de la librería `mapSpain`. Todo el análisis se
va a realizar empleando RStudio, por lo que se empezará abriendo el programa y
creando un nuevo proyecto.

::: {#ex-crea .exercise name="Creación del proyecto"}
Cree un proyecto para trabajar todo lo referente al caso.
:::

::: {#sol-crea .solution}
Para crear un proyecto siga la secuencia: *File> New Proyect> New File> RMD*
:::

El conjunto de datos proporcionado `tempmin.csv` contiene el nivel de
temperatura del aire en España entre el 6 y el 10 de Enero de
2021[^aplicaciones_libro-1]. Estos datos han sido descargados usando la librería
**climaemet** [@R-climaemet] y han sido posteriormente tratados para su uso en
esta práctica.

[^aplicaciones_libro-1]: Las fechas seleccionadas coinciden con el periodo en el
    que la tormenta Filomena tuvo su auge en la Península Ibérica.

A continuación es necesario importar la base de datos de temperatura mínima. El
archivo está en formato csv, por lo cual, es un fichero de texto plano. Se
pueden usar varias funciones para realizar la importación. Se emplearán los
paquetes del **tidyverse** [@R-tidyverse] para realizar todo el tratamiento de
datos.

::: {#ex2 .exercise name="Importación de los datos"}
Importe los datos `tempmin.csv` y guárdelos en un objeto llamado `tmin`.
:::

::: {#sol2 .solution}
Use la librería **readr**.
:::

```{r tmin_import, message=FALSE}
# Cada uno debe seleccionar el directorio donde tiene los datos, de ahí
# que sea conveniente trabajar con proyectos.
library(readr)
tmin <- read_csv("data/tempmin.csv")
```

El conjunto de datos `tempmin` es un data frame que contiene 5 variables:

-   `fecha`: Indicando la fecha de observación.

-   `indicativo`: Es el identificador de la estación de la AEMET que registró el
    dato.

-   `tmin`: Dato de temperatura mínima registrada en cada fecha por la estación
    correspondiente en grados centígrados.

-   `longitud, latitud`: Coordenadas geográficas de la estación

::: {#ex3 .exercise name="Descripción de los datos"}
Con la función `head()` describa, en forma de tabla, la información que contiene
el objeto `tmin` y compruebe que se corresponde con la descrita.
:::

```{r tmin-head}
knitr::kable(head(tmin), caption = "Detalle del objeto tmin")
```

Una de las clases de objetos espaciales más utilzada en R es `sf`. Sin embargo,
dependiendo del análisis que se quiera realizar hay otras muy comunes como
`geodata`, `spatastat`, etc..

A continuación se convertirá el objeto `tmin` (`data.frame`) a un objeto de la
clase `geodata`, una clase muy utilizada para trabajar con datos espaciales y
requerida por la librería `geoR` [@R-geor]. Estos objetos contienen las
coordenadas y la variable objeto de estudio. Para mayor detalle ver
`??as.geodata`. Obsérvese como varía la variable a través de los ejes longitud y
latitud. Observe tambien la forma campaniforme de la distribución de la
variable.

::: {#ex4 .exercise name="Descripción de los datos"}
Del objeto `tmin` seleccione el día **8 de enero de 2022** y las variables
`longitud`, `latitud` y `tmin` para crear el objeto y llámelo `tmin_geoR`. A
continuación describa analítica y gráficamente dicho objeto.
:::

```{r fig.cap="Convertir `data.frame` a `geodata`"}
library(dplyr)
library(geoR)

tmin_geoR <- tmin %>%
  filter(fecha == "2021-01-08") %>%
  # Seleccionamos las columnas de interés
  dplyr::select(longitud, latitud, tmin) %>%
  # Y creamos el objeto geodata
  as.geodata(
    coords.col = 1:2,
    data.col = 3
  )


summary(tmin_geoR)
plot(tmin_geoR)
```

En esta ocasión, convertiremos los datos de `tmin` en un objeto espacial `sf`,
es decir, datos espaciales de tipo vector.

Los datos de `tmin` contienen coordenadas geográficas longitud/latitud, así que
como se vió en la Sección \@ref(CRS) el CRS a emplear ha de ser un CRS
geográfico. Usaremos el código **EPSG:4326**, que corresponde a coordenadas
geográficas y suele ser el habitual en este tipo de situaciones.

::: {#ex5 .exercise name="Convertir data.frame a sf"}
Del objeto `tmin` seleccione las variables `longitud`, `latitud` y `tmin` para
crear el objeto sf y llámelo `tmin_sf`. A continuación describa el objeto
creado.
:::

```{r}
library(sf)

tmin_sf <- st_as_sf(tmin,
  coords = c("longitud", "latitud"),
  crs = 4326
)

tmin_sf
```

La siguiente tarea será representar las estaciones que monitorizan la
temperatura mínima en un mapa de España.

::: {#ex6 .exercise name="Reprsentación espacial de la clase sf"}
Represente un mapa de España, con las Comunidades Autónomas de incluidas,
excepto las Islas Canarias (por simplicidad)
:::

::: {#sol6 .solution}
Una opción es utilizar un paquete API que nos proporciona esta información en
formato `sf`, el paquete **mapSpain**.
:::

```{r fig.cap="Mapa de España (Sin Canarias)"}
library(mapSpain)
# sf object
esp <- esp_get_ccaa() %>%
  # No vamos a usar Canarias en este análisis
  filter(ine.ccaa.name != "Canarias")


plot(esp$geometry) # Dibujamos el mapa de España menos las Islas Canarias
```

Como se comentó en la Sección \@ref(CRS), cuando se emplean datos geográficos
provenientes de varias fuentes, es necesario asegurarse de que ambos objetos
están usando el mismo CRS.

::: {#ex7 .exercise name="CRS"}
¿Tengo el Sistema de referencia de coordenadas (CRS) de las estaciones de
monitoreo en la misma proyección que el contorno de España? Compruebelo.
:::

```{r chek_crs}
st_crs(tmin_sf) == st_crs(esp)
```

Se ha comprobado que no lo están, por lo que hay que proyectar las coordenadas a
un CRS común.

::: {#ex8 .exercise name="CRS"}
Proyecte las coordenadas de los objetos `tmin_sf` y `esp` al CRS de referencia
de `tmin_sf`. Compruébelo.
:::

```{r}
esp2 <- st_transform(esp, st_crs(tmin_sf))

st_crs(tmin_sf) == st_crs(esp2)
```

Para dibujar las estaciones de monitoreo con el contorno de España, existen
varias opciones de paquetes, **ggplot2** [@R-ggplot] (paquete de referencia en
representaciones gráficas), **tmap** [@R-tmap] o **mapsf** [@R-mapsf] (estos dos
últimos especializados en mapas temáticos).

::: {#ex9 .exercise name="CRS"}
Represente, con el paquete **ggplot2**, las estaciones de monitorero de AEMET en
la Península Ibérica.
:::

```{r fig.cap="Estaciones de AEMET en la Península Ibérica"}
library(ggplot2)

ggplot(esp2) +
  # Para graficar objetos sf debemos usar geom_sf()
  geom_sf() +
  geom_sf(data = tmin_sf) +
  theme_light() +
  # labs(
  #  title = "Estaciones de monitoreo AEMET en  España",
  #  subtitle = "excluyendo las Islas Canarias"
  # ) +
  theme(
    plot.title = element_text(
      size = 12,
      face = "bold"
    ),
    plot.subtitle = element_text(
      size = 8,
      face = "italic"
    )
  )
```

Una vez represtadas las coordenadas, es decir, las estaciones de monitoreo dónde
se ha medido la variable temperatura mínima `tmin`, el siguiente paso será
representar el valor que toma la variable en esas coodenadas. La base `tmin`
contiene información temporal para para varios días, por lo que, como este
análisis es meramente espacial se elegirá un día que se fijará para todo el
análisis.

::: {#ex10 .exercise name="plot-sp1"}
Representamos la variable temperatura mínima `tmin` para el día **8 de enero de
2021**. Guarde la base de datos espacial para ese día en un objeto de nombre
`tmin_8enero`.
:::

```{r plot-base-tmin, fig.cap="Mapa de puntos con temperatura mínima (8-enero-2021)"}

# Seleccionaremos los datos correspondientes al 8 de enero de 2021
tmin_8enero <- tmin_sf %>%
  filter(fecha == "2021-01-08")


# Mapa temático en el que se representan los valores de temperatura mínima
# registrados en cada estación mediante un código de colores
plot(tmin_8enero["tmin"],
  # main = "Temperatura mínima (8-enero-2021)",
  pch = 8
)
```

El mapa ha quedado muy bien, pero quizá los colores y el formato elegido no sean
los más adecuados para este tipo de representaciones...

::: {.exercise name="plot-sp2"}
Utilice los parámetros espaciales de los que dispone, las coordenadas y el
contorno de España para graficar y contar la historia de **Filomena**
adecuadamente.
:::

```{r spatial-plots, echo=FALSE, fig.cap="Mapa completo con temperatura mínima (8-enero-2021)"}

# Especificamos la paleta de color a utilizar
cortes <- c(-Inf, seq(-20, 20, 2.5), Inf)
colores <- hcl.colors(15, "PuOr", rev = TRUE)


ggplot() +
  geom_sf(
    data = esp2,
    fill = "grey99"
  ) +
  geom_sf(
    data = tmin_8enero,
    aes(color = tmin),
    size = 4,
    alpha = .7
  ) +
  labs(color = "Temp. mín") +
  scale_color_gradientn(
    colours = colores,
    breaks = cortes,
    labels = function(x) {
      paste0(x, "º")
    },
    guide = "legend"
  ) +
  theme_light() +
  # labs(
  #  title = "Temperatura mínima (8-enero-2021)"
  # ) +
  theme(
    plot.title = element_text(
      size = 12,
      face = "bold"
    ),
    plot.subtitle = element_text(
      size = 8,
      face = "italic"
    )
  )
```

La visión que ofrece el la Fig. \@ref(fig:spatial-plots) de Filomena es muy
informativa, vemos como los datos nos cuentan la historia de lo que ocurrió ese
día. La pena es que no existan estaciones de monitoreo en todos los puntos de
España para conocer el valor de la temperatura mínima en cualquier lugar del
país. ¿Podríamos tener un mapa de interpolación para tener una estimación de la
temperatura mínima en las partes donde la AEMET no tiene estación de monitoreo?

Tal y como se avanzó en el Capítulo \@ref(dep-esp), parece lógico pensar que
aquellos puntos que estén cerca tendrán valores similares. Por tanto, tomemos
ventaja de las propiedades de la dependencia espacial y utilicemos un método de
interpolación sencillo, en este caso un método determinista, la Distancia
Inversa Ponderada, comúnmente conocido por su acrónimo inglés IDW (Inverse
distance weighted), el cual es uno de los métodos más simples para llevar para
llevar a cabo una interpolación espacial.

En este tipo de análisis espacial, es crucial que el CRS sea el apropiado. En
este caso, ya se definió el CRS como un CRS geográfico (es decir, usando
coordenadas de longitud y latitud). Sin embargo, para el ejercicio de
interpolación es más adecuado usar un CRS local (que provoca pocas deformaciones
en la proyección de España) y en alguna unidad de distancia, como metros (ya se
vio en la Sección \@ref(CRS) que en los CRS geográficos las unidades son
grados).

::: {#ex11 .exercise name="Obtención de CRS sugerido para un conjuto de datos"}
Utilice el paquete **crsuggest** para observar los CRS sugeridos y, si es
necesario, transforme la proyección de los datos.
:::

```{r}
library(crsuggest)

sugiere <- suggest_crs(tmin_8enero, units = "m", limit = 5)

# Usamos la sugerencia del paquete
crs_sugerido <- st_crs(sugiere[1, ]$crs_proj4) # Madrid

esp3 <- st_transform(esp2, crs_sugerido)
tmin_8enero3 <- st_transform(tmin_8enero, crs_sugerido)
```

Una vez solucionado el problema de las proyecciones, antes de llevar a cabo la
interpolación, es necesario generar una malla que representará las celdas de las
que queremos obtener el valor interpolado. Dado que hemos proyectado nuestros
datos a un CRS cuya unidad son los metros, podemos definir el tamaño de cada
celda en metros cuadrados. En este caso vamos a usar celdas de 100 kms cuadrados
(10 x 10 kms).

::: {#ex12 .exercise name="Creación y representación de una malla de interpolación"}
Genere un grid y llámelo `malla_sf` (puede fijar una semilla si lo desea) y
grafíque la superficie construida.
:::

```{r create-grid2, fig.cap="Malla de puntos para interpolación"}

# Generación de la superficie a interpolar
set.seed(9876) # Aseguramos que el grid generado siempre es igual

malla_sf <- st_make_grid(
  esp3,
  cellsize = 10000
)

# Representación de la superficie construida añadiendo el contorno de España
ggplot(esp3) +
  geom_sf() +
  geom_sf(
    data = malla_sf,
    size = 0.1,
    col = "red", alpha = 1,
    fill = NA
  ) +
  geom_sf(
    data = tmin_8enero3,
    aes(fill = "AEMET Stations"), size = 4, shape = 21,
    color = "blue"
  ) +
  scale_fill_manual(values = adjustcolor("blue", alpha.f = 0.2)) +
  theme_void() +
  theme(legend.position = "bottom")
```

Se puede observar claramente cada una de las celdas que se han creado. La
interpolación asignará un valor a cada uno de ellas.

A continuación podemos llevar a cabo la interpolación usando el paquete
**gstat** [@R-gstat]. Además, en lugar de celdas (polígonos) es necesario usar
puntos en la interpolación. Calcularemos, por tanto, un punto representativo de
cada celda creada en la superficie anterior `malla_sf`, el centroide, que es el
punto resultante de realizar la media arimética de las coordenadas de los puntos
que componen los lados de cada celda.

::: {#ex13 .exercise name="Interpolación a través de la Distancia Inversa Ponderada"}
Calcule los centroides de los polígonos de la malla construida en el Ejercicio
\@ref(exr:ex12) con la función `st_centroid()` y realice una interpolación de la
variable temperatura mínima `tmin` para el día 8 de enero de 2021 con el método
IDW usando la librería **gstat** y la función `idw`. Guarde el resultado
obtenido en un objeto llamado `tmin_idw`. Utilice la función `help(idw)` si
requiere información sobre cómo introducir los parámetros en la función.

Examine la información del objeto `tmin_idw`, a través de la función `head()`,
:::

```{r}
# Calculamos una malla con centroides
malla_sf_cent <- st_centroid(malla_sf, of_largest_polygon = TRUE)

library(gstat)
tmin_idw <- idw(
  # Indicamos la variable que queremos interpolar
  tmin ~ 1,
  # Indicamos el conjunto de datos donde está la variable
  tmin_8enero3,
  # Indicamos la malla de destino, en sf
  newdata = malla_sf_cent,
  idp = 2.0 # Especifica la potencia de la IDW
)
head(tmin_idw)
```

Un tipo de mapas muy utilizado cuando se trabaja con datos espaciales son los
mapas de contorno. Es muy visual y ayuda a interpretar el mapa interpolado,
añadir unas lineas de contorno al mapa interpolado.

::: {#ex14 .exercise name="Mapa de interpolación y contorno con raster"}
Represente los valores interpolados, `tmin_idw`, y añada unas lineas de
contorno. Utilice el paquete **raster** para convertir el objeto interpolado a
pixeles.
:::

```{r, fig.cap="Mapa raster con lineas de nivel"}
# Convertimos de sf a SpatiaPixels
# Esto funciona porque nuestros puntos sf están espaciados regularmente

tmin_pixels <- tmin_idw %>%
  as("Spatial") %>%
  as("SpatialPixels")


library(raster)
# Creamos un raster de nuestros pixels
rast_esp <- raster(tmin_pixels)

# Transferimos valores del objeto sf al raster
rast_esp2 <- rasterize(
  tmin_idw,
  rast_esp,
  field = "var1.pred", ## valores de predicción idw
  fun = mean
)

# Además, podemos recortar el raster a la forma de España

rast_esp_mask <- mask(rast_esp2, esp3)

plot(rast_esp_mask, col = colores)
contour(rast_esp2, add = TRUE)
```

::: {#ex15 .exercise name="Mapa de interpolación con `ggplot`"}
Repita el mapa de \@ref(exr:ex14) usando **ggplot2** y la función
`geom_contour_filled()`.
:::

```{r fig.cap="Temperatura mínima interpolada. 8 de Enero 2021. "}

# Creo una tabla para geom contour
coordenadas <- st_coordinates(tmin_idw)
valor <- tmin_idw$var1.pred

idw_df <- data.frame(
  # Necesitamos redondear las coordenadas
  latitud = round(coordenadas[, 2], 6),
  longitud = round(coordenadas[, 1], 6),
  tmin = valor
)

ggplot() +
  geom_contour_filled(
    data = idw_df,
    aes(x = longitud, y = latitud, z = tmin),
    na.rm = TRUE,
    breaks = cortes
  ) +
  # Reajustamos la escala de colores
  scale_fill_manual(values = colores) +
  # CCAA
  geom_sf(data = esp3, fill = NA) +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  labs(
    fill = "Temp. (º)"
  )
```
